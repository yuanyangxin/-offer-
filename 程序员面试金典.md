### 1、确定字符互异

不使用额外的存储结构

```java
import java.util.*;

public class Different {
    public boolean checkDifferent(String iniString) {
        // write code here
        for(int i=0;i<iniString.length();i++)
        {
            for(int j=i+1;j<iniString.length();j++)
            {
                if(iniString.charAt(i) == iniString.charAt(j))
                {
                    return false;
                }
            }
        }
        return true;
    }
}
```

### 2、原串翻转

不使用额外的存储结构

```java
import java.util.*;

public class Reverse {
    public String reverseString(String iniString) {
        // write code here
        String arrry = "" ;
        for (int i =iniString.length()-1 ; i >-1 ; i--) {
            arrry=arrry+iniString.charAt(i);
        }
        return arrry; 
    }
}
```

### 3、确定两串乱序同构

```java
import java.util.*;

public class Same {
    public boolean checkSam(String stringA, String stringB) {
        // write code here
        int lenA = stringA.length();
        int lenB = stringB.length();
        if(lenA != lenB){
            return false;
        }
        int[] strA = new int[256];
        int[] strB = new int[256];
        for(int i=0;i<lenA;i++)
        {
            strA[stringA.charAt(i)]++;
            strB[stringB.charAt(i)]++;
        }
        for(int i=0;i<256;i++)
        {
            if(strA[i] != strB[i])
            {
                return false;
            }
        }
        return true;
    }
}
```

### 4.空格替换

```java
import java.util.*;

public class Replacement {
    public String replaceSpace(String iniString, int length) {
        // write code here
        int count = 0;
        for(int i=0;i<length;i++)
        {
            if(iniString.charAt(i)==' ')
                count++;
        }
        int newlength = length + count*2;
        char[] newChar = new char[newlength];
        for(int i=length-1;i>=0;i--)
        {
            if(iniString.charAt(i) != ' ')
            {
                newChar[--newlength] = iniString.charAt(i);
            }else{
                newChar[--newlength]='0';
                newChar[--newlength]='2';
                newChar[--newlength]='%';
            }
        }
        String res = "";
        for(int i=0;i<newChar.length;i++)
        {
            res = res+newChar[i];
        }
        return res;
    }
}
```

### 5.基本字符串压缩

```java
import java.util.*;

public class Zipper {
    public String zipString(String iniString) {
        // write code here
        if(iniString.trim().length() == 0||iniString == null)
            return "";
        StringBuilder res = new StringBuilder("");
        char[] iniStr = iniString.toCharArray();
        char pre;
        pre = iniStr[0];
        int count =1;
        for(int i=1;i<iniStr.length;i++)
        {
            if(pre == iniStr[i])
            {
                count++;
            }else{
                res.append(pre+""+count);
                count =1;
                pre = iniStr[i];
            }
        }
        res.append(pre+""+count);
        if(res.toString().length()>=iniString.length())
        {
            return iniString;
        }else{
            return res.toString();
        }
    }
}
```

### 6、清除行列

```java
import java.util.*;

public class Clearer {
    public int[][] clearZero(int[][] mat, int n) {
        // write code here
        boolean[] row = new boolean[n];
        boolean[] column = new boolean[n];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(mat[i][j] == 0)
                {
                    row[i] = true;
                    column[j] = true;
                }
            }
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(row[i] || column[j])
                {
                    mat[i][j] = 0;
                }
            }
        }
        return mat;
    }
}
```

### 7.翻转子串



```java
import java.util.*;

public class ReverseEqual {
    public boolean checkReverseEqual(String s1, String s2) {
        // write code here
        if((s1=="" && s2 =="") || (s1.length() == 0 && s2.length() ==0))
            return true;
        if(s1.length() != s2.length())
            return false;
        s1 = s1+s1;
        if(s1.indexOf(s2) != -1)
        {
            return true;
        }else{
            return false;
        }
    }
}
```

### 8.链表中倒数第k个结点

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) 
    {
        if(head == null || k <= 0 ) return null;
        int i;
        int j;
        ListNode p1 = head;
        ListNode p2 = head;
        for( i = 0; i < k-1; i++) // 注意：倒数第k个节点只走k-1步
        {
            if(p1.next != null)
            {
                p1 = p1.next;
            }else{
                return null;
            }
        }
        while(p1.next != null)
        {
                p1 = p1.next;
                p2 = p2.next;
        }
        return p2;
    }
}
```

### 9.访问单个节点的删除

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Remove {
    public boolean removeNode(ListNode pNode) {
        // write code here
        if(pNode.next == null || pNode == null)
            return false;
        pNode.val = pNode.next.val;
        pNode.next = pNode.next.next;
        return true;
    }
}
```

### 10.链表分割

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
//  设置大小链表，小于的数放入小链表，大于的数放入大链表
//  最后把大小链表进行连接
public class Partition {
    public ListNode partition(ListNode pHead, int x) {
        // write code here
        if(pHead == null || pHead.next == null)
            return pHead;
        ListNode sNode = new ListNode(-1);
        ListNode bNode = new ListNode(-1);
        ListNode small = sNode;
        ListNode big = bNode;
        ListNode cur = pHead;
        // 把剩下的节点放入大小链表
        while(cur != null)
        {
            if(cur.val < x){
                small.next = new ListNode(cur.val);
                small = small.next;
            }else{
                big.next = new ListNode(cur.val);
                big = big.next;
            }
            cur = cur.next;
        }
        // 把大小链表串接起来
        cur = sNode;
        while(cur.next!=null && cur.next.val != -1)
        {
            cur = cur.next;
        }
        cur.next = bNode.next;
        return  sNode.next;  
    }
}
```

### 11.链式A+B



```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Plus {
    public ListNode plusAB(ListNode a, ListNode b) {
        StringBuffer resa = new StringBuffer();
        StringBuffer resb = new StringBuffer();
        while(a != null)
        {
            resa.append(a.val);
            a = a.next;
        }
        while(b != null)
        {
            resb.append(b.val);
            b =b.next;
        }
        resa = resa.reverse();
        resb = resb.reverse();
        Integer x = Integer.parseInt(resa.toString());
        Integer y =Integer.parseInt(resb.toString());
        Integer result = x+y;
        String resstr = Integer.toString(result);
        ListNode res = new ListNode(-1);
        ListNode cur = res;
        for(int i= resstr.length()-1;i>=0;i--)
        {
            cur.next  = new ListNode(Integer.parseInt(resstr.charAt(i)+""));
            cur = cur.next;
        }
        return res.next;
    }
}
```



### 12.集合栈



```java
import java.util.*;

public class SetOfStacks {
    public ArrayList<ArrayList<Integer>> setOfStacks(int[][] ope, int size) {
        // write code here
        ArrayList<ArrayList<Integer>> list=new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> curArray=new ArrayList<Integer>(size);
        list.add(curArray);
        for(int i=0;i<ope.length;i++){
            switch(ope[i][0]){
            //1:push
            case 1:
                //当前数组未满
                if(curArray.size()!=size){
                    curArray.add(ope[i][1]);
                }
                else{
                    curArray=new ArrayList<Integer>(size);
                    list.add(curArray);
                    curArray.add(ope[i][1]);
                }
                break;
            //2:pop
            case 2:
                //当前数组不为空
                if(curArray.size()!=0){
                    curArray.remove(curArray.size()-1);
                }
                else{
                    list.remove(list.size()-1);
                    curArray=list.get(list.size()-1);
                    curArray.remove(curArray.size()-1);
                }
                break;
            }
        }
        return list;
    }
}
```

### 13.用两个栈实现队列

```java
/**
* push先全部放stack1里面
  pop的时候先把stack1里面的东西都放到pop的stack2中
  push里面所有东西都要倒完
*/
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) 
    {
        stack1.push(node);
    }
    
    public int pop() 
    {
        int a;
        if(stack2.empty())
        {
            while(!stack1.empty())
            {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

### 14.双栈排序

```java
import java.util.*;

public class TwoStacks {
    public ArrayList<Integer> twoStacksSort(int[] numbers) {
        // write code here
        // 构建栈
        ArrayList<Integer> list = new ArrayList<Integer>();
        
        Stack<Integer> inistack = new Stack<Integer>();
        for(int i=numbers.length-1;i>=0;i--)
        {
            inistack.push(numbers[i]);
        }
        
        // 中间栈，先把大于要压入值的中间栈弹出，然后在把值压入中间栈
        Stack<Integer> temp = new Stack<Integer>();
        
        while(!inistack.empty())
        {
            if(temp.isEmpty())
            {
                temp.push(inistack.pop());
            }else{
                int tmp = inistack.pop();
                while(!temp.isEmpty() && temp.peek()>tmp)
                {
                    inistack.push(temp.pop());
                }
                temp.push(tmp);
            }
        }
        while(!temp.isEmpty())
        {
            list.add(temp.pop());
        }
        return list;
    }
}
```

### 15.猫狗收容所



 

```java
import java.util.*;

public class CatDogAsylum {
public ArrayList<Integer> asylum(int[][] ope) {
         // write code here
         ArrayList<Integer> r = new ArrayList<Integer>();// 存放最终收养序列
         ArrayList<Integer> animal = new ArrayList<Integer>();// 存放进入收容所的动物
         int temp=0;
         for (int i = 0; i < ope.length; i++) {
             switch (ope[i][0]) {
             // 有动物进入收容所
             case 1:
                 animal.add(ope[i][1]);
                 break;
             // 有人收养动物
             case 2:
                 // 第一种收养方式
                 if (!animal.isEmpty()&&ope[i][1] == 0) {
                     r.add(animal.get(0));
                     animal.remove(0);
                 }
                 // 收养狗
                 else if (ope[i][1] == 1) {
                     for(temp=0;temp<animal.size();temp++){
                         if(animal.get(temp)>0){
                             r.add(animal.get(temp));
                             animal.remove(temp);
                             break;
                         }
                     }
                 }
                 // 收养猫
                 else if(ope[i][1] == -1){
                     for(temp=0;temp<animal.size();temp++){
                         if(animal.get(temp)<0){
                             r.add(animal.get(temp));
                             animal.remove(temp);
                             break;
                         }
                     }
                 }
                 break;
             }
         }
         return r;
     }
}
```

### 16.有向路径检查

```java
//深度优先遍历（DFS）：随机选一个节点，访问后再随机选下一个未访问节点；没有未访问节点后则回退
// 数组（map）记录节点是否被访问，用栈记录访问的先后顺序；
// 当节点的所有临近点都被访问时，需要回退，正巧用栈弹出

//广度优先遍历(BFS)：随机选一个节点，再访问该节点所有的未被访问的临近节点；重复此过程，直至所有节点被访问
// 数组记录节点是否被访问，用队列记录访问的先后顺序；
// 当节点的所有临近点都被访问时，需要回退，正巧用栈弹出

import java.util.*;

/*
public class UndirectedGraphNode {
    int label = 0;
    UndirectedGraphNode left = null;
    UndirectedGraphNode right = null;
    ArrayList<UndirectedGraphNode> neighbors = new ArrayList<UndirectedGraphNode>();

    public UndirectedGraphNode(int label) {
        this.label = label;
    }
}*/
public class Path 
{
    public boolean checkPath(UndirectedGraphNode a, UndirectedGraphNode b) {
        return check(a, b) || check(b, a);
    }

    public boolean check(UndirectedGraphNode a, UndirectedGraphNode b) {
        // TODO Auto-generated method stub
        if (a == null || b == null) {
            return false;
        }
        if (a == b) {
            return true;
        }
        Map<UndirectedGraphNode, Boolean> checkedMap = new HashMap<UndirectedGraphNode, Boolean>();
        LinkedList<UndirectedGraphNode> searchQueue = new LinkedList<UndirectedGraphNode>();
        searchQueue.push(a);
        checkedMap.put(a, true);
        while (!searchQueue.isEmpty()) {
            UndirectedGraphNode currentNode = searchQueue.pop();
            if (currentNode.neighbors != null) {
                for (int i = 0; i < currentNode.neighbors.size(); i++) {
                    UndirectedGraphNode neib = currentNode.neighbors.get(i);
                    if (neib != null) {
                        if (neib == b) {
                            return true;
                        }
                        if (checkedMap.get(neib) == null || !checkedMap.get(neib)) {
                            searchQueue.push(neib);
                            checkedMap.put(neib, true);
                        }
                    }
                }
            }
        }
        return false;
    }
}
```

### 17.高度最小的BST

 

```java
import java.util.*;

/**
二叉查找树
若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
任意节点的左、右子树也分别为二叉查找树；
没有键值相等的节点。 **/
// 最小高度为 log2(元素数量)+1
public class MinimalBST {
    public int buildMinimalBST(int[] vals) {
        // write code here
        int num = vals.length;
        return (int)(Math.log(num+1)/Math.log(2))+1;
    }
}
```

```java
import java.util.*;

public class MinimalBST {
    public int buildMinimalBST(int[] vals) {
        // write code here
        if(vals.length == 0)
            return 0;
        int length = vals.length;
        TreeNode node = build(vals,0,length-1);
        return max(node);
    }
    
    public TreeNode build(int[] vals,int left,int right)
    {
        if(left>right)
            return null;
        int mid = (left+right)/2;
        TreeNode root = new TreeNode(vals[mid]);
        root.left = build(vals,left,mid-1);
        root.right = build(vals,mid+1,right);
        return root;
    }
    
    public int max(TreeNode root)
    {
        if(root == null)
            return 0;
        int left = max(root.left)+1;
        int right = max(root.right)+1;
        return Math.max(left,right);
    }
}
```

### 18.输出单层结点

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class TreeLevel {
    public ListNode getTreeLevel(TreeNode root, int dep) {
        // write code here
        if(root ==null) return null;
        Queue<TreeNode> que =new LinkedList<>();
        int len =0,i;
        que.add(root);
        while(dep >1 && !que.isEmpty())
        {
            len = que.size();
            for(i=0;i<len;i++)
            {
                TreeNode p = que.poll();
                if(p.left != null)
                    que.add(p.left);
                if(p.right != null)
                    que.add(p.right);
            }
            dep--;
        }
        ListNode res = new ListNode(que.poll().val);
        ListNode tem = res;
        while(!que.isEmpty())
        {
            tem.next = new ListNode(que.poll().val);
            tem =tem.next;
        }
        return res;
    }
}
```

### 19.检查是否为BST

```java
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class Checker {
    public boolean checkBST(TreeNode root) {
        // write code here
        Stack<TreeNode> stack =new Stack<TreeNode>();
        TreeNode p = root;
        int pre = 0;
        boolean isFirst = true;
        while(p != null || !stack.isEmpty())
        {
            while(p != null)
            {
                stack.push(p);
                p = p.left;
            }
            p=stack.pop();
            if(isFirst)
            {
                pre = p.val;
                isFirst = false;
            }else if(p.val < pre){
                return false;
            }else{
                pre =p.val;
            }
            p = p.right;
        }
        return true;
    }
}
```

### 20.寻找下一个结点

 

```java
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class Successor {
    public int findSucc(TreeNode root, int p) {
        boolean isFound = false;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode cur = root;
        while(cur!=null||!stack.isEmpty()){
            while(cur!=null){
                stack.add(cur);
                cur = cur.left;
            }
            if(!stack.isEmpty()){
                TreeNode q = stack.pop();
                if(isFound) return q.val;
                else if(q.val==p) isFound = true;
                cur = q.right;
            }
        }
        return -1;
    }      
}
```

### 21.最近公共祖先

```java
import java.util.*;

public class LCA {
    public int getLCA(int a, int b) {
        // write code here
        while(a != b )
        {
            if(a>b)
                a =a/2;
            else
                b =b/2;
        }
        return a;
    }
}
```

### 22.二叉树中和为某一值

 

```java
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    ArrayList<ArrayList<Integer>> list= new ArrayList<ArrayList<Integer>>();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) 
    {
        ArrayList<Integer> list1 = new ArrayList<>();
        getPath(root,target,list1);
        return list;
    }
    
    public void getPath(TreeNode root, int target, ArrayList<Integer> list1)
    {
        if(root == null || target<0) 
            return;
        list1.add(root.val);
        if(target -root.val ==0 && root.left == null && root.right == null)
        {
            list.add(new ArrayList<Integer>(list1));
        }
        getPath(root.left,target-root.val,list1);
        getPath(root.right,target-root.val,list1);
        list1.remove(list1.size()-1);
    }
}
```

