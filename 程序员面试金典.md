### 1、确定字符互异

不使用额外的存储结构

```java
import java.util.*;

public class Different {
    public boolean checkDifferent(String iniString) {
        // write code here
        for(int i=0;i<iniString.length();i++)
        {
            for(int j=i+1;j<iniString.length();j++)
            {
                if(iniString.charAt(i) == iniString.charAt(j))
                {
                    return false;
                }
            }
        }
        return true;
    }
}
```

### 2、原串翻转

不使用额外的存储结构

```java
import java.util.*;

public class Reverse {
    public String reverseString(String iniString) {
        // write code here
        String arrry = "" ;
        for (int i =iniString.length()-1 ; i >-1 ; i--) {
            arrry=arrry+iniString.charAt(i);
        }
        return arrry; 
    }
}
```

### 3、确定两串乱序同构

```java
import java.util.*;

public class Same {
    public boolean checkSam(String stringA, String stringB) {
        // write code here
        int lenA = stringA.length();
        int lenB = stringB.length();
        if(lenA != lenB){
            return false;
        }
        int[] strA = new int[256];
        int[] strB = new int[256];
        for(int i=0;i<lenA;i++)
        {
            strA[stringA.charAt(i)]++;
            strB[stringB.charAt(i)]++;
        }
        for(int i=0;i<256;i++)
        {
            if(strA[i] != strB[i])
            {
                return false;
            }
        }
        return true;
    }
}
```

### 4.空格替换

```java
import java.util.*;

public class Replacement {
    public String replaceSpace(String iniString, int length) {
        // write code here
        int count = 0;
        for(int i=0;i<length;i++)
        {
            if(iniString.charAt(i)==' ')
                count++;
        }
        int newlength = length + count*2;
        char[] newChar = new char[newlength];
        for(int i=length-1;i>=0;i--)
        {
            if(iniString.charAt(i) != ' ')
            {
                newChar[--newlength] = iniString.charAt(i);
            }else{
                newChar[--newlength]='0';
                newChar[--newlength]='2';
                newChar[--newlength]='%';
            }
        }
        String res = "";
        for(int i=0;i<newChar.length;i++)
        {
            res = res+newChar[i];
        }
        return res;
    }
}
```

### 5.基本字符串压缩

```java
import java.util.*;

public class Zipper {
    public String zipString(String iniString) {
        // write code here
        if(iniString.trim().length() == 0||iniString == null)
            return "";
        StringBuilder res = new StringBuilder("");
        char[] iniStr = iniString.toCharArray();
        char pre;
        pre = iniStr[0];
        int count =1;
        for(int i=1;i<iniStr.length;i++)
        {
            if(pre == iniStr[i])
            {
                count++;
            }else{
                res.append(pre+""+count);
                count =1;
                pre = iniStr[i];
            }
        }
        res.append(pre+""+count);
        if(res.toString().length()>=iniString.length())
        {
            return iniString;
        }else{
            return res.toString();
        }
    }
}
```

### 6、清除行列

```java
import java.util.*;

public class Clearer {
    public int[][] clearZero(int[][] mat, int n) {
        // write code here
        boolean[] row = new boolean[n];
        boolean[] column = new boolean[n];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(mat[i][j] == 0)
                {
                    row[i] = true;
                    column[j] = true;
                }
            }
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(row[i] || column[j])
                {
                    mat[i][j] = 0;
                }
            }
        }
        return mat;
    }
}
```

### 7.翻转子串



```java
import java.util.*;

public class ReverseEqual {
    public boolean checkReverseEqual(String s1, String s2) {
        // write code here
        if((s1=="" && s2 =="") || (s1.length() == 0 && s2.length() ==0))
            return true;
        if(s1.length() != s2.length())
            return false;
        s1 = s1+s1;
        if(s1.indexOf(s2) != -1)
        {
            return true;
        }else{
            return false;
        }
    }
}
```

### 8.链表中倒数第k个结点

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) 
    {
        if(head == null || k <= 0 ) return null;
        int i;
        int j;
        ListNode p1 = head;
        ListNode p2 = head;
        for( i = 0; i < k-1; i++) // 注意：倒数第k个节点只走k-1步
        {
            if(p1.next != null)
            {
                p1 = p1.next;
            }else{
                return null;
            }
        }
        while(p1.next != null)
        {
                p1 = p1.next;
                p2 = p2.next;
        }
        return p2;
    }
}
```

### 9.访问单个节点的删除

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Remove {
    public boolean removeNode(ListNode pNode) {
        // write code here
        if(pNode.next == null || pNode == null)
            return false;
        pNode.val = pNode.next.val;
        pNode.next = pNode.next.next;
        return true;
    }
}
```

### 10.链表分割

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
//  设置大小链表，小于的数放入小链表，大于的数放入大链表
//  最后把大小链表进行连接
public class Partition {
    public ListNode partition(ListNode pHead, int x) {
        // write code here
        if(pHead == null || pHead.next == null)
            return pHead;
        ListNode sNode = new ListNode(-1);
        ListNode bNode = new ListNode(-1);
        ListNode small = sNode;
        ListNode big = bNode;
        ListNode cur = pHead;
        // 把剩下的节点放入大小链表
        while(cur != null)
        {
            if(cur.val < x){
                small.next = new ListNode(cur.val);
                small = small.next;
            }else{
                big.next = new ListNode(cur.val);
                big = big.next;
            }
            cur = cur.next;
        }
        // 把大小链表串接起来
        cur = sNode;
        while(cur.next!=null && cur.next.val != -1)
        {
            cur = cur.next;
        }
        cur.next = bNode.next;
        return  sNode.next;  
    }
}
```

### 11.链式A+B



```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Plus {
    public ListNode plusAB(ListNode a, ListNode b) {
        StringBuffer resa = new StringBuffer();
        StringBuffer resb = new StringBuffer();
        while(a != null)
        {
            resa.append(a.val);
            a = a.next;
        }
        while(b != null)
        {
            resb.append(b.val);
            b =b.next;
        }
        resa = resa.reverse();
        resb = resb.reverse();
        Integer x = Integer.parseInt(resa.toString());
        Integer y =Integer.parseInt(resb.toString());
        Integer result = x+y;
        String resstr = Integer.toString(result);
        ListNode res = new ListNode(-1);
        ListNode cur = res;
        for(int i= resstr.length()-1;i>=0;i--)
        {
            cur.next  = new ListNode(Integer.parseInt(resstr.charAt(i)+""));
            cur = cur.next;
        }
        return res.next;
    }
}
```



### 12.集合栈



```java
import java.util.*;

public class SetOfStacks {
    public ArrayList<ArrayList<Integer>> setOfStacks(int[][] ope, int size) {
        // write code here
        ArrayList<ArrayList<Integer>> list=new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> curArray=new ArrayList<Integer>(size);
        list.add(curArray);
        for(int i=0;i<ope.length;i++){
            switch(ope[i][0]){
            //1:push
            case 1:
                //当前数组未满
                if(curArray.size()!=size){
                    curArray.add(ope[i][1]);
                }
                else{
                    curArray=new ArrayList<Integer>(size);
                    list.add(curArray);
                    curArray.add(ope[i][1]);
                }
                break;
            //2:pop
            case 2:
                //当前数组不为空
                if(curArray.size()!=0){
                    curArray.remove(curArray.size()-1);
                }
                else{
                    list.remove(list.size()-1);
                    curArray=list.get(list.size()-1);
                    curArray.remove(curArray.size()-1);
                }
                break;
            }
        }
        return list;
    }
}
```

### 13.用两个栈实现队列

```java
/**
* push先全部放stack1里面
  pop的时候先把stack1里面的东西都放到pop的stack2中
  push里面所有东西都要倒完
*/
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) 
    {
        stack1.push(node);
    }
    
    public int pop() 
    {
        int a;
        if(stack2.empty())
        {
            while(!stack1.empty())
            {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

### 14.双栈排序

```java
import java.util.*;

public class TwoStacks {
    public ArrayList<Integer> twoStacksSort(int[] numbers) {
        // write code here
        // 构建栈
        ArrayList<Integer> list = new ArrayList<Integer>();
        
        Stack<Integer> inistack = new Stack<Integer>();
        for(int i=numbers.length-1;i>=0;i--)
        {
            inistack.push(numbers[i]);
        }
        
        // 中间栈，先把大于要压入值的中间栈弹出，然后在把值压入中间栈
        Stack<Integer> temp = new Stack<Integer>();
        
        while(!inistack.empty())
        {
            if(temp.isEmpty())
            {
                temp.push(inistack.pop());
            }else{
                int tmp = inistack.pop();
                while(!temp.isEmpty() && temp.peek()>tmp)
                {
                    inistack.push(temp.pop());
                }
                temp.push(tmp);
            }
        }
        while(!temp.isEmpty())
        {
            list.add(temp.pop());
        }
        return list;
    }
}
```

### 15.猫狗收容所



 

```java
import java.util.*;

public class CatDogAsylum {
public ArrayList<Integer> asylum(int[][] ope) {
         // write code here
         ArrayList<Integer> r = new ArrayList<Integer>();// 存放最终收养序列
         ArrayList<Integer> animal = new ArrayList<Integer>();// 存放进入收容所的动物
         int temp=0;
         for (int i = 0; i < ope.length; i++) {
             switch (ope[i][0]) {
             // 有动物进入收容所
             case 1:
                 animal.add(ope[i][1]);
                 break;
             // 有人收养动物
             case 2:
                 // 第一种收养方式
                 if (!animal.isEmpty()&&ope[i][1] == 0) {
                     r.add(animal.get(0));
                     animal.remove(0);
                 }
                 // 收养狗
                 else if (ope[i][1] == 1) {
                     for(temp=0;temp<animal.size();temp++){
                         if(animal.get(temp)>0){
                             r.add(animal.get(temp));
                             animal.remove(temp);
                             break;
                         }
                     }
                 }
                 // 收养猫
                 else if(ope[i][1] == -1){
                     for(temp=0;temp<animal.size();temp++){
                         if(animal.get(temp)<0){
                             r.add(animal.get(temp));
                             animal.remove(temp);
                             break;
                         }
                     }
                 }
                 break;
             }
         }
         return r;
     }
}
```

### 16.有向路径检查

```java
//深度优先遍历（DFS）：随机选一个节点，访问后再随机选下一个未访问节点；没有未访问节点后则回退
// 数组（map）记录节点是否被访问，用栈记录访问的先后顺序；
// 当节点的所有临近点都被访问时，需要回退，正巧用栈弹出

//广度优先遍历(BFS)：随机选一个节点，再访问该节点所有的未被访问的临近节点；重复此过程，直至所有节点被访问
// 数组记录节点是否被访问，用队列记录访问的先后顺序；
// 当节点的所有临近点都被访问时，需要回退，正巧用栈弹出

import java.util.*;

/*
public class UndirectedGraphNode {
    int label = 0;
    UndirectedGraphNode left = null;
    UndirectedGraphNode right = null;
    ArrayList<UndirectedGraphNode> neighbors = new ArrayList<UndirectedGraphNode>();

    public UndirectedGraphNode(int label) {
        this.label = label;
    }
}*/
public class Path 
{
    public boolean checkPath(UndirectedGraphNode a, UndirectedGraphNode b) {
        return check(a, b) || check(b, a);
    }

    public boolean check(UndirectedGraphNode a, UndirectedGraphNode b) {
        // TODO Auto-generated method stub
        if (a == null || b == null) {
            return false;
        }
        if (a == b) {
            return true;
        }
        Map<UndirectedGraphNode, Boolean> checkedMap = new HashMap<UndirectedGraphNode, Boolean>();
        LinkedList<UndirectedGraphNode> searchQueue = new LinkedList<UndirectedGraphNode>();
        searchQueue.push(a);
        checkedMap.put(a, true);
        while (!searchQueue.isEmpty()) {
            UndirectedGraphNode currentNode = searchQueue.pop();
            if (currentNode.neighbors != null) {
                for (int i = 0; i < currentNode.neighbors.size(); i++) {
                    UndirectedGraphNode neib = currentNode.neighbors.get(i);
                    if (neib != null) {
                        if (neib == b) {
                            return true;
                        }
                        if (checkedMap.get(neib) == null || !checkedMap.get(neib)) {
                            searchQueue.push(neib);
                            checkedMap.put(neib, true);
                        }
                    }
                }
            }
        }
        return false;
    }
}
```

