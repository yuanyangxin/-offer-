### 1、确定字符互异

不使用额外的存储结构

```java
import java.util.*;

public class Different {
    public boolean checkDifferent(String iniString) {
        // write code here
        for(int i=0;i<iniString.length();i++)
        {
            for(int j=i+1;j<iniString.length();j++)
            {
                if(iniString.charAt(i) == iniString.charAt(j))
                {
                    return false;
                }
            }
        }
        return true;
    }
}
```

### 2、原串翻转

不使用额外的存储结构

```java
import java.util.*;

public class Reverse {
    public String reverseString(String iniString) {
        // write code here
        String arrry = "" ;
        for (int i =iniString.length()-1 ; i >-1 ; i--) {
            arrry=arrry+iniString.charAt(i);
        }
        return arrry; 
    }
}
```

### 3、确定两串乱序同构

```java
import java.util.*;

public class Same {
    public boolean checkSam(String stringA, String stringB) {
        // write code here
        int lenA = stringA.length();
        int lenB = stringB.length();
        if(lenA != lenB){
            return false;
        }
        int[] strA = new int[256];
        int[] strB = new int[256];
        for(int i=0;i<lenA;i++)
        {
            strA[stringA.charAt(i)]++;
            strB[stringB.charAt(i)]++;
        }
        for(int i=0;i<256;i++)
        {
            if(strA[i] != strB[i])
            {
                return false;
            }
        }
        return true;
    }
}
```

### 4.空格替换

```java
import java.util.*;

public class Replacement {
    public String replaceSpace(String iniString, int length) {
        // write code here
        int count = 0;
        for(int i=0;i<length;i++)
        {
            if(iniString.charAt(i)==' ')
                count++;
        }
        int newlength = length + count*2;
        char[] newChar = new char[newlength];
        for(int i=length-1;i>=0;i--)
        {
            if(iniString.charAt(i) != ' ')
            {
                newChar[--newlength] = iniString.charAt(i);
            }else{
                newChar[--newlength]='0';
                newChar[--newlength]='2';
                newChar[--newlength]='%';
            }
        }
        String res = "";
        for(int i=0;i<newChar.length;i++)
        {
            res = res+newChar[i];
        }
        return res;
    }
}
```

### 5.基本字符串压缩

```java
import java.util.*;

public class Zipper {
    public String zipString(String iniString) {
        // write code here
        if(iniString.trim().length() == 0||iniString == null)
            return "";
        StringBuilder res = new StringBuilder("");
        char[] iniStr = iniString.toCharArray();
        char pre;
        pre = iniStr[0];
        int count =1;
        for(int i=1;i<iniStr.length;i++)
        {
            if(pre == iniStr[i])
            {
                count++;
            }else{
                res.append(pre+""+count);
                count =1;
                pre = iniStr[i];
            }
        }
        res.append(pre+""+count);
        if(res.toString().length()>=iniString.length())
        {
            return iniString;
        }else{
            return res.toString();
        }
    }
}
```

### 6、清除行列

```java
import java.util.*;

public class Clearer {
    public int[][] clearZero(int[][] mat, int n) {
        // write code here
        boolean[] row = new boolean[n];
        boolean[] column = new boolean[n];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(mat[i][j] == 0)
                {
                    row[i] = true;
                    column[j] = true;
                }
            }
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(row[i] || column[j])
                {
                    mat[i][j] = 0;
                }
            }
        }
        return mat;
    }
}
```

### 7.翻转子串



```java
import java.util.*;

public class ReverseEqual {
    public boolean checkReverseEqual(String s1, String s2) {
        // write code here
        if((s1=="" && s2 =="") || (s1.length() == 0 && s2.length() ==0))
            return true;
        if(s1.length() != s2.length())
            return false;
        s1 = s1+s1;
        if(s1.indexOf(s2) != -1)
        {
            return true;
        }else{
            return false;
        }
    }
}
```

### 8.链表中倒数第k个结点

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) 
    {
        if(head == null || k <= 0 ) return null;
        int i;
        int j;
        ListNode p1 = head;
        ListNode p2 = head;
        for( i = 0; i < k-1; i++) // 注意：倒数第k个节点只走k-1步
        {
            if(p1.next != null)
            {
                p1 = p1.next;
            }else{
                return null;
            }
        }
        while(p1.next != null)
        {
                p1 = p1.next;
                p2 = p2.next;
        }
        return p2;
    }
}
```

### 9.访问单个节点的删除

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Remove {
    public boolean removeNode(ListNode pNode) {
        // write code here
        if(pNode.next == null || pNode == null)
            return false;
        pNode.val = pNode.next.val;
        pNode.next = pNode.next.next;
        return true;
    }
}
```

### 10.链表分割

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
//  设置大小链表，小于的数放入小链表，大于的数放入大链表
//  最后把大小链表进行连接
public class Partition {
    public ListNode partition(ListNode pHead, int x) {
        // write code here
        if(pHead == null || pHead.next == null)
            return pHead;
        ListNode sNode = new ListNode(-1);
        ListNode bNode = new ListNode(-1);
        ListNode small = sNode;
        ListNode big = bNode;
        ListNode cur = pHead;
        // 把剩下的节点放入大小链表
        while(cur != null)
        {
            if(cur.val < x){
                small.next = new ListNode(cur.val);
                small = small.next;
            }else{
                big.next = new ListNode(cur.val);
                big = big.next;
            }
            cur = cur.next;
        }
        // 把大小链表串接起来
        cur = sNode;
        while(cur.next!=null && cur.next.val != -1)
        {
            cur = cur.next;
        }
        cur.next = bNode.next;
        return  sNode.next;  
    }
}
```

### 11.链式A+B



```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Plus {
    public ListNode plusAB(ListNode a, ListNode b) {
        StringBuffer resa = new StringBuffer();
        StringBuffer resb = new StringBuffer();
        while(a != null)
        {
            resa.append(a.val);
            a = a.next;
        }
        while(b != null)
        {
            resb.append(b.val);
            b =b.next;
        }
        resa = resa.reverse();
        resb = resb.reverse();
        Integer x = Integer.parseInt(resa.toString());
        Integer y =Integer.parseInt(resb.toString());
        Integer result = x+y;
        String resstr = Integer.toString(result);
        ListNode res = new ListNode(-1);
        ListNode cur = res;
        for(int i= resstr.length()-1;i>=0;i--)
        {
            cur.next  = new ListNode(Integer.parseInt(resstr.charAt(i)+""));
            cur = cur.next;
        }
        return res.next;
    }
}
```

