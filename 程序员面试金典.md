### 1、确定字符互异

不使用额外的存储结构

```java
import java.util.*;

public class Different {
    public boolean checkDifferent(String iniString) {
        // write code here
        for(int i=0;i<iniString.length();i++)
        {
            for(int j=i+1;j<iniString.length();j++)
            {
                if(iniString.charAt(i) == iniString.charAt(j))
                {
                    return false;
                }
            }
        }
        return true;
    }
}
```

### 2、原串翻转

不使用额外的存储结构

```java
import java.util.*;

public class Reverse {
    public String reverseString(String iniString) {
        // write code here
        String arrry = "" ;
        for (int i =iniString.length()-1 ; i >-1 ; i--) {
            arrry=arrry+iniString.charAt(i);
        }
        return arrry; 
    }
}
```

### 3、确定两串乱序同构

```java
import java.util.*;

public class Same {
    public boolean checkSam(String stringA, String stringB) {
        // write code here
        int lenA = stringA.length();
        int lenB = stringB.length();
        if(lenA != lenB){
            return false;
        }
        int[] strA = new int[256];
        int[] strB = new int[256];
        for(int i=0;i<lenA;i++)
        {
            strA[stringA.charAt(i)]++;
            strB[stringB.charAt(i)]++;
        }
        for(int i=0;i<256;i++)
        {
            if(strA[i] != strB[i])
            {
                return false;
            }
        }
        return true;
    }
}
```

### 4.空格替换

```java
import java.util.*;

public class Replacement {
    public String replaceSpace(String iniString, int length) {
        // write code here
        int count = 0;
        for(int i=0;i<length;i++)
        {
            if(iniString.charAt(i)==' ')
                count++;
        }
        int newlength = length + count*2;
        char[] newChar = new char[newlength];
        for(int i=length-1;i>=0;i--)
        {
            if(iniString.charAt(i) != ' ')
            {
                newChar[--newlength] = iniString.charAt(i);
            }else{
                newChar[--newlength]='0';
                newChar[--newlength]='2';
                newChar[--newlength]='%';
            }
        }
        String res = "";
        for(int i=0;i<newChar.length;i++)
        {
            res = res+newChar[i];
        }
        return res;
    }
}
```

### 5.基本字符串压缩

```java
import java.util.*;

public class Zipper {
    public String zipString(String iniString) {
        // write code here
        if(iniString.trim().length() == 0||iniString == null)
            return "";
        StringBuilder res = new StringBuilder("");
        char[] iniStr = iniString.toCharArray();
        char pre;
        pre = iniStr[0];
        int count =1;
        for(int i=1;i<iniStr.length;i++)
        {
            if(pre == iniStr[i])
            {
                count++;
            }else{
                res.append(pre+""+count);
                count =1;
                pre = iniStr[i];
            }
        }
        res.append(pre+""+count);
        if(res.toString().length()>=iniString.length())
        {
            return iniString;
        }else{
            return res.toString();
        }
    }
}
```

### 6、清除行列

```java
import java.util.*;

public class Clearer {
    public int[][] clearZero(int[][] mat, int n) {
        // write code here
        boolean[] row = new boolean[n];
        boolean[] column = new boolean[n];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(mat[i][j] == 0)
                {
                    row[i] = true;
                    column[j] = true;
                }
            }
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(row[i] || column[j])
                {
                    mat[i][j] = 0;
                }
            }
        }
        return mat;
    }
}
```

### 7.翻转子串



```java
import java.util.*;

public class ReverseEqual {
    public boolean checkReverseEqual(String s1, String s2) {
        // write code here
        if((s1=="" && s2 =="") || (s1.length() == 0 && s2.length() ==0))
            return true;
        if(s1.length() != s2.length())
            return false;
        s1 = s1+s1;
        if(s1.indexOf(s2) != -1)
        {
            return true;
        }else{
            return false;
        }
    }
}
```

### 8.链表中倒数第k个结点

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) 
    {
        if(head == null || k <= 0 ) return null;
        int i;
        int j;
        ListNode p1 = head;
        ListNode p2 = head;
        for( i = 0; i < k-1; i++) // 注意：倒数第k个节点只走k-1步
        {
            if(p1.next != null)
            {
                p1 = p1.next;
            }else{
                return null;
            }
        }
        while(p1.next != null)
        {
                p1 = p1.next;
                p2 = p2.next;
        }
        return p2;
    }
}
```

### 9.访问单个节点的删除

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Remove {
    public boolean removeNode(ListNode pNode) {
        // write code here
        if(pNode.next == null || pNode == null)
            return false;
        pNode.val = pNode.next.val;
        pNode.next = pNode.next.next;
        return true;
    }
}
```

### 10.链表分割

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
//  设置大小链表，小于的数放入小链表，大于的数放入大链表
//  最后把大小链表进行连接
public class Partition {
    public ListNode partition(ListNode pHead, int x) {
        // write code here
        if(pHead == null || pHead.next == null)
            return pHead;
        ListNode sNode = new ListNode(-1);
        ListNode bNode = new ListNode(-1);
        ListNode small = sNode;
        ListNode big = bNode;
        ListNode cur = pHead;
        // 把剩下的节点放入大小链表
        while(cur != null)
        {
            if(cur.val < x){
                small.next = new ListNode(cur.val);
                small = small.next;
            }else{
                big.next = new ListNode(cur.val);
                big = big.next;
            }
            cur = cur.next;
        }
        // 把大小链表串接起来
        cur = sNode;
        while(cur.next!=null && cur.next.val != -1)
        {
            cur = cur.next;
        }
        cur.next = bNode.next;
        return  sNode.next;  
    }
}
```

### 11.链式A+B



```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Plus {
    public ListNode plusAB(ListNode a, ListNode b) {
        StringBuffer resa = new StringBuffer();
        StringBuffer resb = new StringBuffer();
        while(a != null)
        {
            resa.append(a.val);
            a = a.next;
        }
        while(b != null)
        {
            resb.append(b.val);
            b =b.next;
        }
        resa = resa.reverse();
        resb = resb.reverse();
        Integer x = Integer.parseInt(resa.toString());
        Integer y =Integer.parseInt(resb.toString());
        Integer result = x+y;
        String resstr = Integer.toString(result);
        ListNode res = new ListNode(-1);
        ListNode cur = res;
        for(int i= resstr.length()-1;i>=0;i--)
        {
            cur.next  = new ListNode(Integer.parseInt(resstr.charAt(i)+""));
            cur = cur.next;
        }
        return res.next;
    }
}
```



### 12.集合栈



```java
import java.util.*;

public class SetOfStacks {
    public ArrayList<ArrayList<Integer>> setOfStacks(int[][] ope, int size) {
        // write code here
        ArrayList<ArrayList<Integer>> list=new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> curArray=new ArrayList<Integer>(size);
        list.add(curArray);
        for(int i=0;i<ope.length;i++){
            switch(ope[i][0]){
            //1:push
            case 1:
                //当前数组未满
                if(curArray.size()!=size){
                    curArray.add(ope[i][1]);
                }
                else{
                    curArray=new ArrayList<Integer>(size);
                    list.add(curArray);
                    curArray.add(ope[i][1]);
                }
                break;
            //2:pop
            case 2:
                //当前数组不为空
                if(curArray.size()!=0){
                    curArray.remove(curArray.size()-1);
                }
                else{
                    list.remove(list.size()-1);
                    curArray=list.get(list.size()-1);
                    curArray.remove(curArray.size()-1);
                }
                break;
            }
        }
        return list;
    }
}
```

### 13.用两个栈实现队列

```java
/**
* push先全部放stack1里面
  pop的时候先把stack1里面的东西都放到pop的stack2中
  push里面所有东西都要倒完
*/
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) 
    {
        stack1.push(node);
    }
    
    public int pop() 
    {
        int a;
        if(stack2.empty())
        {
            while(!stack1.empty())
            {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

### 14.双栈排序

```java
import java.util.*;

public class TwoStacks {
    public ArrayList<Integer> twoStacksSort(int[] numbers) {
        // write code here
        // 构建栈
        ArrayList<Integer> list = new ArrayList<Integer>();
        
        Stack<Integer> inistack = new Stack<Integer>();
        for(int i=numbers.length-1;i>=0;i--)
        {
            inistack.push(numbers[i]);
        }
        
        // 中间栈，先把大于要压入值的中间栈弹出，然后在把值压入中间栈
        Stack<Integer> temp = new Stack<Integer>();
        
        while(!inistack.empty())
        {
            if(temp.isEmpty())
            {
                temp.push(inistack.pop());
            }else{
                int tmp = inistack.pop();
                while(!temp.isEmpty() && temp.peek()>tmp)
                {
                    inistack.push(temp.pop());
                }
                temp.push(tmp);
            }
        }
        while(!temp.isEmpty())
        {
            list.add(temp.pop());
        }
        return list;
    }
}
```

### 15.猫狗收容所



 

```java
import java.util.*;

public class CatDogAsylum {
public ArrayList<Integer> asylum(int[][] ope) {
         // write code here
         ArrayList<Integer> r = new ArrayList<Integer>();// 存放最终收养序列
         ArrayList<Integer> animal = new ArrayList<Integer>();// 存放进入收容所的动物
         int temp=0;
         for (int i = 0; i < ope.length; i++) {
             switch (ope[i][0]) {
             // 有动物进入收容所
             case 1:
                 animal.add(ope[i][1]);
                 break;
             // 有人收养动物
             case 2:
                 // 第一种收养方式
                 if (!animal.isEmpty()&&ope[i][1] == 0) {
                     r.add(animal.get(0));
                     animal.remove(0);
                 }
                 // 收养狗
                 else if (ope[i][1] == 1) {
                     for(temp=0;temp<animal.size();temp++){
                         if(animal.get(temp)>0){
                             r.add(animal.get(temp));
                             animal.remove(temp);
                             break;
                         }
                     }
                 }
                 // 收养猫
                 else if(ope[i][1] == -1){
                     for(temp=0;temp<animal.size();temp++){
                         if(animal.get(temp)<0){
                             r.add(animal.get(temp));
                             animal.remove(temp);
                             break;
                         }
                     }
                 }
                 break;
             }
         }
         return r;
     }
}
```

### 16.有向路径检查

```java
//深度优先遍历（DFS）：随机选一个节点，访问后再随机选下一个未访问节点；没有未访问节点后则回退
// 数组（map）记录节点是否被访问，用栈记录访问的先后顺序；
// 当节点的所有临近点都被访问时，需要回退，正巧用栈弹出

//广度优先遍历(BFS)：随机选一个节点，再访问该节点所有的未被访问的临近节点；重复此过程，直至所有节点被访问
// 数组记录节点是否被访问，用队列记录访问的先后顺序；
// 当节点的所有临近点都被访问时，需要回退，正巧用栈弹出

import java.util.*;

/*
public class UndirectedGraphNode {
    int label = 0;
    UndirectedGraphNode left = null;
    UndirectedGraphNode right = null;
    ArrayList<UndirectedGraphNode> neighbors = new ArrayList<UndirectedGraphNode>();

    public UndirectedGraphNode(int label) {
        this.label = label;
    }
}*/
public class Path 
{
    public boolean checkPath(UndirectedGraphNode a, UndirectedGraphNode b) {
        return check(a, b) || check(b, a);
    }

    public boolean check(UndirectedGraphNode a, UndirectedGraphNode b) {
        // TODO Auto-generated method stub
        if (a == null || b == null) {
            return false;
        }
        if (a == b) {
            return true;
        }
        Map<UndirectedGraphNode, Boolean> checkedMap = new HashMap<UndirectedGraphNode, Boolean>();
        LinkedList<UndirectedGraphNode> searchQueue = new LinkedList<UndirectedGraphNode>();
        searchQueue.push(a);
        checkedMap.put(a, true);
        while (!searchQueue.isEmpty()) {
            UndirectedGraphNode currentNode = searchQueue.pop();
            if (currentNode.neighbors != null) {
                for (int i = 0; i < currentNode.neighbors.size(); i++) {
                    UndirectedGraphNode neib = currentNode.neighbors.get(i);
                    if (neib != null) {
                        if (neib == b) {
                            return true;
                        }
                        if (checkedMap.get(neib) == null || !checkedMap.get(neib)) {
                            searchQueue.push(neib);
                            checkedMap.put(neib, true);
                        }
                    }
                }
            }
        }
        return false;
    }
}
```

### 17.高度最小的BST

 

```java
import java.util.*;

/**
二叉查找树
若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
任意节点的左、右子树也分别为二叉查找树；
没有键值相等的节点。 **/
// 最小高度为 log2(元素数量)+1
public class MinimalBST {
    public int buildMinimalBST(int[] vals) {
        // write code here
        int num = vals.length;
        return (int)(Math.log(num+1)/Math.log(2))+1;
    }
}
```

```java
import java.util.*;

public class MinimalBST {
    public int buildMinimalBST(int[] vals) {
        // write code here
        if(vals.length == 0)
            return 0;
        int length = vals.length;
        TreeNode node = build(vals,0,length-1);
        return max(node);
    }
    
    public TreeNode build(int[] vals,int left,int right)
    {
        if(left>right)
            return null;
        int mid = (left+right)/2;
        TreeNode root = new TreeNode(vals[mid]);
        root.left = build(vals,left,mid-1);
        root.right = build(vals,mid+1,right);
        return root;
    }
    
    public int max(TreeNode root)
    {
        if(root == null)
            return 0;
        int left = max(root.left)+1;
        int right = max(root.right)+1;
        return Math.max(left,right);
    }
}
```

### 18.输出单层结点

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class TreeLevel {
    public ListNode getTreeLevel(TreeNode root, int dep) {
        // write code here
        if(root ==null) return null;
        Queue<TreeNode> que =new LinkedList<>();
        int len =0,i;
        que.add(root);
        while(dep >1 && !que.isEmpty())
        {
            len = que.size();
            for(i=0;i<len;i++)
            {
                TreeNode p = que.poll();
                if(p.left != null)
                    que.add(p.left);
                if(p.right != null)
                    que.add(p.right);
            }
            dep--;
        }
        ListNode res = new ListNode(que.poll().val);
        ListNode tem = res;
        while(!que.isEmpty())
        {
            tem.next = new ListNode(que.poll().val);
            tem =tem.next;
        }
        return res;
    }
}
```

### 19.检查是否为BST

```java
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class Checker {
    public boolean checkBST(TreeNode root) {
        // write code here
        Stack<TreeNode> stack =new Stack<TreeNode>();
        TreeNode p = root;
        int pre = 0;
        boolean isFirst = true;
        while(p != null || !stack.isEmpty())
        {
            while(p != null)
            {
                stack.push(p);
                p = p.left;
            }
            p=stack.pop();
            if(isFirst)
            {
                pre = p.val;
                isFirst = false;
            }else if(p.val < pre){
                return false;
            }else{
                pre =p.val;
            }
            p = p.right;
        }
        return true;
    }
}
```

### 20.寻找下一个结点

 

```java
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class Successor {
    public int findSucc(TreeNode root, int p) {
        boolean isFound = false;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode cur = root;
        while(cur!=null||!stack.isEmpty()){
            while(cur!=null){
                stack.add(cur);
                cur = cur.left;
            }
            if(!stack.isEmpty()){
                TreeNode q = stack.pop();
                if(isFound) return q.val;
                else if(q.val==p) isFound = true;
                cur = q.right;
            }
        }
        return -1;
    }      
}
```

### 21.最近公共祖先

```java
import java.util.*;

public class LCA {
    public int getLCA(int a, int b) {
        // write code here
        while(a != b )
        {
            if(a>b)
                a =a/2;
            else
                b =b/2;
        }
        return a;
    }
}
```

### 22.二叉树中和为某一值

 

```java
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    ArrayList<ArrayList<Integer>> list= new ArrayList<ArrayList<Integer>>();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) 
    {
        ArrayList<Integer> list1 = new ArrayList<>();
        getPath(root,target,list1);
        return list;
    }
    
    public void getPath(TreeNode root, int target, ArrayList<Integer> list1)
    {
        if(root == null || target<0) 
            return;
        list1.add(root.val);
        if(target -root.val ==0 && root.left == null && root.right == null)
        {
            list.add(new ArrayList<Integer>(list1));
        }
        getPath(root.left,target-root.val,list1);
        getPath(root.right,target-root.val,list1);
        list1.remove(list1.size()-1);
    }
}
```

### 23.二进制插入

```java
import java.util.*;

public class BinInsert {
    public int binInsert(int n, int m, int j, int i) 
    {
        // write code here
        return n+(m<<j);
    }
}
```

### 24.二进制小数

```java
//利用十进制小数转换为二进制的特点：小数*2
//如果实数大于1，说明小数点后一位是1，如果小于1，说明小数点后一位是0
import java.util.*;

public class BinDecimal {
    public String printBin(double num) 
    {
        // write code here
        StringBuffer sb = new StringBuffer("0.");
        while(num != 0.0)
        {
            if(sb.length() >32 )
                return "Error";
            num *=2;
            if(num>=1)
            {
                sb.append("1");
                num -=1;
            }else{
                sb.append("0");
            }
        }
        return sb.toString();
    }
}
```

### 25.最接近的数

```java
import java.util.*;

public class CloseNumber {
    public int[] getCloseNumber(int x) {
        // write code here
        int min =x-1, max = x+1;
        while(Integer.bitCount(x) != Integer.bitCount(min) && min>=0)
            min--;
        while(Integer.bitCount(x) != Integer.bitCount(max))
            max++;
        int[] arr={min,max};
        return arr;
    }
}
```

### 26.整数转化

```java
import java.util.*;

public class Transform {
    public int calcCost(int A, int B) {
        // write code here
        return Integer.bitCount(A^B);
    }
}
```

### 27.奇偶位交换

```java
import java.util.*;

public class Exchange {
    public int exchangeOddEven(int x) {
        // write code here
        String binStr = Integer.toBinaryString(x);
        if(binStr.length()%2 == 1)
        {
            binStr = "0"+binStr;
        }
        char[] charArr = binStr.toCharArray();
        for(int i=1;i<charArr.length;i+=2)
        {
            char temp = charArr[i-1];
            charArr[i-1] = charArr[i];
            charArr[i] = temp;
        }
        return Integer.valueOf(new String(charArr),2);
    }
}
```

### 28.找出缺失的整数

```java
import java.util.*;

public class Finder {
    public int findMissing(int[][] numbers, int n) {
        // write code here
        int sum1 = (0+n)*(n+1)/2;
        int sum2 =0;
        for(int i=0;i<n;i++)
        {
            int number =0;
            for(int j=0;j<numbers[i].length;j++)
            {
               number = number*2 +numbers[i][numbers[i].length-1-j];
            }
            sum2+=number;
        }
        return sum1-sum2;
    }
}
```

### 29.像素设定

```java
/**
采用最普通的算法一位一位的进行填色，
即0->1,1->1（或）
因此就是要找到当前要填的像素位于数组的那个位置，位于哪个位，
然后进行或运算
*/
import java.util.*;

public class Render {
    public int[] renderPixel(int[] screen, int x, int y) {
        // write code here
        for(int i=x;i<=y;i++)
        {
            int k = i % 8;
            int t = i/8;
            screen[t] = screen[t] | (1<<k);
        }
        return screen;
    }
}
```

### 30.判断直线相交

```java
import java.util.*;

public class CrossLine {
    public boolean checkCrossLine(double s1, double s2, double y1, double y2) {
        // write code here
        double s = Math.abs(s1-s2);
        double y = Math.abs(y1-y2);
        if((s<1e-6) && (y<1e-6))
            return true;
        else if((s<1e-6) && (y>=1e-6))
            return false;
        else
            return true;
    }
}
```

### 31.加法运算替代

```java
import java.util.*;

public class AddSubstitution {
    public int calc(int a, int b, int type) {
        // write code here
        int res = 0;
        switch(type)
        {
            case 1:
                res = mult(a,b);
                break;
            case 0:
                res = div(a,b);
                break;
            case -1:
                res= sub(a,b);
                break;
        }
        return res;
    }
    
    public int mult(int a,int b)
    {
        int r=0;
        for(int i=0;i<a;i++)
        {
            r+=b;
        }
        return r;
    }
    
    public int div(int a,int b)
    {
        for(int i=1;i<=a;i++)
            if(mult(b,i) <=a&&mult(b,i+1)>a)
                return i;
        return 0;
    }
    
    public int sub(int a,int b)
    {
        if(a>=b)
        {
            for(int i=0;i<a;i++)
            {
                if(i+b==a)
                    return i;
            }
        }
        return mult(sub(b,a),-1);
    }
}
```

### 32.平分的直线

```java
import java.util.*;

/*
public class Point {
    int x;
    int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public Point() {
        this.x = 0;
        this.y = 0;
    }
}*/
public class Bipartition {
    public double[] getBipartition(Point[] A, Point[] B) {
        // write code here
        double pointX_A = (A[0].x+A[1].x+A[2].x+A[3].x)/4.0;
        double pointY_A = (A[0].y+A[1].y+A[2].y+A[3].y)/4.0;
        double pointX_B = (B[0].x+B[1].x+B[2].x+B[3].x)/4.0;
        double pointY_B = (B[0].y+B[1].y+B[2].y+B[3].y)/4.0;
        double k = (pointY_A- pointY_B)/(pointX_A-pointX_B);
        double l = pointY_B  - k*pointX_B;
        double[] res =new double[2];
        res[0] = k;
        res[1] = l;
        return res;
    }
}
```

### 33.穿点最多的直线

```java
import java.util.*;

/*
public class Point {
    int x;
    int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public Point() {
        this.x = 0;
        this.y = 0;
    }
}*/
public class DenseLine {
    public double[] getLine(Point[] p, int n) {
        // write code here
        double[] ds = new double[2];
        int max =2;
        int t;
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                double a= (p[i].y-p[j].y)/(p[i].x-p[j].x);
                double b=p[i].y-p[i].x*a;
                t=2;
                for(int z=0;z<n;z++)
                {
                    if(z==i || z==j)
                        continue;
                    if(a == (p[i].y-p[z].y)/(p[i].x-p[z].x))
                    {
                        t++;
                    }
                }
                if(max<t)
                {
                    t=max;
                    ds[0] = a;
                    ds[1] = b;
                }
            }
        }
        return ds;
    }
}
```

###  34.第k个数

```java
import java.util.*;

public class KthNumber {
    public int findKth(int k) 
    {
        // write code here
        int[] array = new int[k];
        int num3=0;
        int num5=0;
        int num7=0;
        array[0] =3;
        array[1] =5;
        array[2]=7;
        for(int i=3;i<k;i++)
        {
            array[i] = Math.min(Math.min(array[num3]*3,array[num5]*5),array[num7]*7);
            if(array[i] == array[num3]*3) num3++;
            if(array[i] == array[num5]*5) num5++;
            if(array[i] == array[num7]*7) num7++;
        }
        return array[k-1];
    }
}
```

### 35.上楼梯

```java
import java.util.*;
/*
思路：上1级有一种，2级上1级后再上1级，3级有上1级之后上2级或上2级之后上1级或直接上3级
4级有1级上3级，2级上2级，3级上1级
总结起来有：f(1)=1,f(2)=2,f(3)=4,f(4)=f(1)+f(2)+f(3);f(5)=f(2)+f(3)+f(4)
f(n)=f(n-1)+f(n-2)+f(n-3);
本来使用递归做的，结果递归做到最后超时了，只好用迭代了；
*/
public class GoUpstairs {
    public int countWays(int n) 
    {
        // write code here
        if(n <1) return 0;
        if(n==1) return 1;
        if(n==2) return 2;
        int[] array = new int[n];
        array[0] =1;
        array[1] = 2;
        array[2] =4;
        for(int i=3;i<n;i++)
        {
            array[i] = ((array[i-1]%1000000007+array[i-2]%1000000007)%1000000007+array[i-3]%1000000007)%1000000007;
        }
        return array[n-1];
    }
}
```

### 36.机器人走方格I

```java
import java.util.*;
/**  动态规划DP
当前子问题的解将由上一次子问题的解推出

*/
public class Robot {
    public int countWays(int x, int y) {
        // write code here
        int[][] dp =new int[x][y];
        dp[0][0] = 1;
        for(int i=1;i<x;i++)
        {
            dp[i][0] = dp[i-1][0];
        }
        for(int i=1;i<y;i++)
        {
            dp[0][i] = dp[0][i-1];
        }
        for(int i=1;i<x;i++)
        {
            for(int j=1;j<y;j++)
            {
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[x-1][y-1];
    }
}
```

### 37.机器人走方格II

```java
import java.util.*;

public class Robot {
    public int countWays(int[][] map, int x, int y) {
    // write code here
    /*
     * 1.判断右下角的点以及起点自身是否为障碍点，若是返回0；
     * 2.若右下角的点非障碍点，判断上面和左边是否为障碍点
     *  1.若全都为障碍点，返回0
     *  2.若一个为障碍点，一个不是，则到该点的路径数等于上一个点的路径数（这是递归的思路）
     * 第2部分可以不用递归，而用循环：
     *  dp[i-1][j-1]表示从(0,0)到(i,j)的方法数，如果(i,j)非1，则为障碍点，对应dp[i-1][j-1]为0
     *  其余情况与一般dp相同
     */
        if(map == null || map.length != x || map[0].length != y){
            return 0;
        }
        if(map[x-1][y-1] != 1 || map[0][0] != 1){//最后一个点为障碍点
            return 0;
        }
        int dp[][] = new int[x][y];
        dp[0][0] = 1;
        for(int i = 1; i < x; i++){
            if(map[i][0] != 1){
                dp[i][0] = 0;
            }else{
                dp[i][0] = dp[i-1][0];
            }
        }
        for(int i = 1; i < y; i++){
            if(map[0][i] != 1){
                dp[0][i] = 0;
            }else{
                dp[0][i] = dp[0][i-1];
            }
        }
        for(int i = 1; i < x; i++){
            for(int j = 1; j < y; j++){
                if(map[i][j] != 1){
                    dp[i][j] = 0;
                }else{
                    dp[i][j] = dp[i-1][j]%1000000007 + dp[i][j-1]%1000000007;
                }
            }
        }
        return (dp[x-1][y-1]%1000000007);
}
}
```

### 38.魔术索引I

```java
import java.util.*;

public class MagicIndex {
    public boolean findMagicIndex(int[] A, int n) 
    {
        // write code here
        if(A == null || A.length !=n || n<=0)
            return false;
        return findMagic(A,0,A.length-1);
    }
    
    public boolean findMagic(int[] A,int begin,int end)
    {
        if(begin > end)
        {
            return false;
        }
        int index = (begin+end)/2;
        if(A[index] == index)
            return true;
        if(index > A[index])
            return findMagic(A,index+1,end);
        else
            return findMagic(A,begin,index-1);
    }
}
```

### 39.魔术索引II

```java
import java.util.*;

public class MagicIndex {
    public boolean findMagicIndex(int[] A, int n) 
    {
        // write code here
        if(A == null || A.length !=n || n<=0)
            return false;
        return findMagic(A,0,n-1);
    }
    
    public boolean findMagic(int[] A,int begin,int end)
    {
        if(begin > end)
        {
            return false;
        }
        int index = (begin+end)/2;
        if(A[index] == index)
            return true;
        return findMagic(A,begin,index-1)||findMagic(A,index+1,end);
    }
}
```

### 40.集合的子集

```java
import java.util.*;

public class Subset {
    public ArrayList<ArrayList<Integer>> getSubsets(int[] A, int n) 
    {
        // write code here
        ArrayList<ArrayList<Integer>> ret = new ArrayList<ArrayList<Integer>>();
        dfs(A,A.length-1,new ArrayList<Integer>(),ret);
        return ret;
    }
    
    public static void dfs(int[] A, int offset, ArrayList<Integer> solution,ArrayList<ArrayList<Integer>> ret)
    {
        for(int i=offset;i>=0;i--)
        {
            solution.add(A[i]);
            dfs(A,i-1,solution,ret);
            solution.remove(solution.size()-1);
        }
        if(solution.size() != 0)
            ret.add(new ArrayList<Integer>(solution));
        if(offset == -1)
            return;
    }
}
```

### 41.字符串排列

```java
import java.util.*;

public class Permutation {
public ArrayList<String> getPermutation(String A) {
    ArrayList<String> list = f(A);
    Collections.sort(list, new Comparator<String>() {
        public int compare(String o1, String o2) {
            return o2.compareTo(o1);
        }
    });
    return list;
}
 
private ArrayList<String> f(String A) {
    ArrayList<String> list = new ArrayList<String>();
    if (A == null || "".equals(A)) { //递归终止条件
        list.add("");
        return list;
    }
    char c = A.charAt(0);
    String l = A.substring(1);
    ArrayList<String> arr = f(l);
    for (String s : arr) {
        for (int i = 0; i <= s.length(); i++) {
            list.add(insert(s, c, i));
        }
    }
    return list;
}
 
public String insert(String s, char b, int i) { //插入字符
    String a = s.substring(0, i);
    String c = s.substring(i, s.length());
    return a + b + c;
}
}
```

### 42.合法括号序列判断

```java
import java.util.*;

public class Parenthesis {
    public boolean chkParenthesis(String A, int n) {
        // write code here
        char[] charr = A.toCharArray();
        int count = 0;
        for(int i=0;i<charr.length;i++)
        {
            if(charr[i] == '(')
            {
                count++;
            }else if(charr[i] == ')')
            {
                count--;
            }else{
                return false;
            }
        }
        if(count == 0)
            return true;
        return false;
    }
}
```

 