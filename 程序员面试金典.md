### 1、确定字符互异

不使用额外的存储结构

```java
import java.util.*;

public class Different {
    public boolean checkDifferent(String iniString) {
        // write code here
        for(int i=0;i<iniString.length();i++)
        {
            for(int j=i+1;j<iniString.length();j++)
            {
                if(iniString.charAt(i) == iniString.charAt(j))
                {
                    return false;
                }
            }
        }
        return true;
    }
}
```

### 2、原串翻转

不使用额外的存储结构

```java
import java.util.*;

public class Reverse {
    public String reverseString(String iniString) {
        // write code here
        String arrry = "" ;
        for (int i =iniString.length()-1 ; i >-1 ; i--) {
            arrry=arrry+iniString.charAt(i);
        }
        return arrry; 
    }
}
```

### 3、确定两串乱序同构

```java
import java.util.*;

public class Same {
    public boolean checkSam(String stringA, String stringB) {
        // write code here
        int lenA = stringA.length();
        int lenB = stringB.length();
        if(lenA != lenB){
            return false;
        }
        int[] strA = new int[256];
        int[] strB = new int[256];
        for(int i=0;i<lenA;i++)
        {
            strA[stringA.charAt(i)]++;
            strB[stringB.charAt(i)]++;
        }
        for(int i=0;i<256;i++)
        {
            if(strA[i] != strB[i])
            {
                return false;
            }
        }
        return true;
    }
}
```

### 4.空格替换

```java
import java.util.*;

public class Replacement {
    public String replaceSpace(String iniString, int length) {
        // write code here
        int count = 0;
        for(int i=0;i<length;i++)
        {
            if(iniString.charAt(i)==' ')
                count++;
        }
        int newlength = length + count*2;
        char[] newChar = new char[newlength];
        for(int i=length-1;i>=0;i--)
        {
            if(iniString.charAt(i) != ' ')
            {
                newChar[--newlength] = iniString.charAt(i);
            }else{
                newChar[--newlength]='0';
                newChar[--newlength]='2';
                newChar[--newlength]='%';
            }
        }
        String res = "";
        for(int i=0;i<newChar.length;i++)
        {
            res = res+newChar[i];
        }
        return res;
    }
}
```

### 5.基本字符串压缩

```java
import java.util.*;

public class Zipper {
    public String zipString(String iniString) {
        // write code here
        if(iniString.trim().length() == 0||iniString == null)
            return "";
        StringBuilder res = new StringBuilder("");
        char[] iniStr = iniString.toCharArray();
        char pre;
        pre = iniStr[0];
        int count =1;
        for(int i=1;i<iniStr.length;i++)
        {
            if(pre == iniStr[i])
            {
                count++;
            }else{
                res.append(pre+""+count);
                count =1;
                pre = iniStr[i];
            }
        }
        res.append(pre+""+count);
        if(res.toString().length()>=iniString.length())
        {
            return iniString;
        }else{
            return res.toString();
        }
    }
}
```

### 6、清除行列

```java
import java.util.*;

public class Clearer {
    public int[][] clearZero(int[][] mat, int n) {
        // write code here
        boolean[] row = new boolean[n];
        boolean[] column = new boolean[n];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(mat[i][j] == 0)
                {
                    row[i] = true;
                    column[j] = true;
                }
            }
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(row[i] || column[j])
                {
                    mat[i][j] = 0;
                }
            }
        }
        return mat;
    }
}
```

### 7.翻转子串



```java
import java.util.*;

public class ReverseEqual {
    public boolean checkReverseEqual(String s1, String s2) {
        // write code here
        if((s1=="" && s2 =="") || (s1.length() == 0 && s2.length() ==0))
            return true;
        if(s1.length() != s2.length())
            return false;
        s1 = s1+s1;
        if(s1.indexOf(s2) != -1)
        {
            return true;
        }else{
            return false;
        }
    }
}
```

### 8.链表中倒数第k个结点

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) 
    {
        if(head == null || k <= 0 ) return null;
        int i;
        int j;
        ListNode p1 = head;
        ListNode p2 = head;
        for( i = 0; i < k-1; i++) // 注意：倒数第k个节点只走k-1步
        {
            if(p1.next != null)
            {
                p1 = p1.next;
            }else{
                return null;
            }
        }
        while(p1.next != null)
        {
                p1 = p1.next;
                p2 = p2.next;
        }
        return p2;
    }
}
```

### 9.访问单个节点的删除

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Remove {
    public boolean removeNode(ListNode pNode) {
        // write code here
        if(pNode.next == null || pNode == null)
            return false;
        pNode.val = pNode.next.val;
        pNode.next = pNode.next.next;
        return true;
    }
}
```

### 10.链表分割

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
//  设置大小链表，小于的数放入小链表，大于的数放入大链表
//  最后把大小链表进行连接
public class Partition {
    public ListNode partition(ListNode pHead, int x) {
        // write code here
        if(pHead == null || pHead.next == null)
            return pHead;
        ListNode sNode = new ListNode(-1);
        ListNode bNode = new ListNode(-1);
        ListNode small = sNode;
        ListNode big = bNode;
        ListNode cur = pHead;
        // 把剩下的节点放入大小链表
        while(cur != null)
        {
            if(cur.val < x){
                small.next = new ListNode(cur.val);
                small = small.next;
            }else{
                big.next = new ListNode(cur.val);
                big = big.next;
            }
            cur = cur.next;
        }
        // 把大小链表串接起来
        cur = sNode;
        while(cur.next!=null && cur.next.val != -1)
        {
            cur = cur.next;
        }
        cur.next = bNode.next;
        return  sNode.next;  
    }
}
```

### 11.链式A+B



```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Plus {
    public ListNode plusAB(ListNode a, ListNode b) {
        StringBuffer resa = new StringBuffer();
        StringBuffer resb = new StringBuffer();
        while(a != null)
        {
            resa.append(a.val);
            a = a.next;
        }
        while(b != null)
        {
            resb.append(b.val);
            b =b.next;
        }
        resa = resa.reverse();
        resb = resb.reverse();
        Integer x = Integer.parseInt(resa.toString());
        Integer y =Integer.parseInt(resb.toString());
        Integer result = x+y;
        String resstr = Integer.toString(result);
        ListNode res = new ListNode(-1);
        ListNode cur = res;
        for(int i= resstr.length()-1;i>=0;i--)
        {
            cur.next  = new ListNode(Integer.parseInt(resstr.charAt(i)+""));
            cur = cur.next;
        }
        return res.next;
    }
}
```



### 12.集合栈



```java
import java.util.*;

public class SetOfStacks {
    public ArrayList<ArrayList<Integer>> setOfStacks(int[][] ope, int size) {
        // write code here
        ArrayList<ArrayList<Integer>> list=new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> curArray=new ArrayList<Integer>(size);
        list.add(curArray);
        for(int i=0;i<ope.length;i++){
            switch(ope[i][0]){
            //1:push
            case 1:
                //当前数组未满
                if(curArray.size()!=size){
                    curArray.add(ope[i][1]);
                }
                else{
                    curArray=new ArrayList<Integer>(size);
                    list.add(curArray);
                    curArray.add(ope[i][1]);
                }
                break;
            //2:pop
            case 2:
                //当前数组不为空
                if(curArray.size()!=0){
                    curArray.remove(curArray.size()-1);
                }
                else{
                    list.remove(list.size()-1);
                    curArray=list.get(list.size()-1);
                    curArray.remove(curArray.size()-1);
                }
                break;
            }
        }
        return list;
    }
}
```

### 13.用两个栈实现队列

```java
/**
* push先全部放stack1里面
  pop的时候先把stack1里面的东西都放到pop的stack2中
  push里面所有东西都要倒完
*/
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) 
    {
        stack1.push(node);
    }
    
    public int pop() 
    {
        int a;
        if(stack2.empty())
        {
            while(!stack1.empty())
            {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

### 14.双栈排序

```java
import java.util.*;

public class TwoStacks {
    public ArrayList<Integer> twoStacksSort(int[] numbers) {
        // write code here
        // 构建栈
        ArrayList<Integer> list = new ArrayList<Integer>();
        
        Stack<Integer> inistack = new Stack<Integer>();
        for(int i=numbers.length-1;i>=0;i--)
        {
            inistack.push(numbers[i]);
        }
        
        // 中间栈，先把大于要压入值的中间栈弹出，然后在把值压入中间栈
        Stack<Integer> temp = new Stack<Integer>();
        
        while(!inistack.empty())
        {
            if(temp.isEmpty())
            {
                temp.push(inistack.pop());
            }else{
                int tmp = inistack.pop();
                while(!temp.isEmpty() && temp.peek()>tmp)
                {
                    inistack.push(temp.pop());
                }
                temp.push(tmp);
            }
        }
        while(!temp.isEmpty())
        {
            list.add(temp.pop());
        }
        return list;
    }
}
```

### 15.猫狗收容所



 

```java
import java.util.*;

public class CatDogAsylum {
public ArrayList<Integer> asylum(int[][] ope) {
         // write code here
         ArrayList<Integer> r = new ArrayList<Integer>();// 存放最终收养序列
         ArrayList<Integer> animal = new ArrayList<Integer>();// 存放进入收容所的动物
         int temp=0;
         for (int i = 0; i < ope.length; i++) {
             switch (ope[i][0]) {
             // 有动物进入收容所
             case 1:
                 animal.add(ope[i][1]);
                 break;
             // 有人收养动物
             case 2:
                 // 第一种收养方式
                 if (!animal.isEmpty()&&ope[i][1] == 0) {
                     r.add(animal.get(0));
                     animal.remove(0);
                 }
                 // 收养狗
                 else if (ope[i][1] == 1) {
                     for(temp=0;temp<animal.size();temp++){
                         if(animal.get(temp)>0){
                             r.add(animal.get(temp));
                             animal.remove(temp);
                             break;
                         }
                     }
                 }
                 // 收养猫
                 else if(ope[i][1] == -1){
                     for(temp=0;temp<animal.size();temp++){
                         if(animal.get(temp)<0){
                             r.add(animal.get(temp));
                             animal.remove(temp);
                             break;
                         }
                     }
                 }
                 break;
             }
         }
         return r;
     }
}
```

### 16.有向路径检查

```java
//深度优先遍历（DFS）：随机选一个节点，访问后再随机选下一个未访问节点；没有未访问节点后则回退
// 数组（map）记录节点是否被访问，用栈记录访问的先后顺序；
// 当节点的所有临近点都被访问时，需要回退，正巧用栈弹出

//广度优先遍历(BFS)：随机选一个节点，再访问该节点所有的未被访问的临近节点；重复此过程，直至所有节点被访问
// 数组记录节点是否被访问，用队列记录访问的先后顺序；
// 当节点的所有临近点都被访问时，需要回退，正巧用栈弹出

import java.util.*;

/*
public class UndirectedGraphNode {
    int label = 0;
    UndirectedGraphNode left = null;
    UndirectedGraphNode right = null;
    ArrayList<UndirectedGraphNode> neighbors = new ArrayList<UndirectedGraphNode>();

    public UndirectedGraphNode(int label) {
        this.label = label;
    }
}*/
public class Path 
{
    public boolean checkPath(UndirectedGraphNode a, UndirectedGraphNode b) {
        return check(a, b) || check(b, a);
    }

    public boolean check(UndirectedGraphNode a, UndirectedGraphNode b) {
        // TODO Auto-generated method stub
        if (a == null || b == null) {
            return false;
        }
        if (a == b) {
            return true;
        }
        Map<UndirectedGraphNode, Boolean> checkedMap = new HashMap<UndirectedGraphNode, Boolean>();
        LinkedList<UndirectedGraphNode> searchQueue = new LinkedList<UndirectedGraphNode>();
        searchQueue.push(a);
        checkedMap.put(a, true);
        while (!searchQueue.isEmpty()) {
            UndirectedGraphNode currentNode = searchQueue.pop();
            if (currentNode.neighbors != null) {
                for (int i = 0; i < currentNode.neighbors.size(); i++) {
                    UndirectedGraphNode neib = currentNode.neighbors.get(i);
                    if (neib != null) {
                        if (neib == b) {
                            return true;
                        }
                        if (checkedMap.get(neib) == null || !checkedMap.get(neib)) {
                            searchQueue.push(neib);
                            checkedMap.put(neib, true);
                        }
                    }
                }
            }
        }
        return false;
    }
}
```

### 17.高度最小的BST

 

```java
import java.util.*;

/**
二叉查找树
若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
任意节点的左、右子树也分别为二叉查找树；
没有键值相等的节点。 **/
// 最小高度为 log2(元素数量)+1
public class MinimalBST {
    public int buildMinimalBST(int[] vals) {
        // write code here
        int num = vals.length;
        return (int)(Math.log(num+1)/Math.log(2))+1;
    }
}
```

```java
import java.util.*;

public class MinimalBST {
    public int buildMinimalBST(int[] vals) {
        // write code here
        if(vals.length == 0)
            return 0;
        int length = vals.length;
        TreeNode node = build(vals,0,length-1);
        return max(node);
    }
    
    public TreeNode build(int[] vals,int left,int right)
    {
        if(left>right)
            return null;
        int mid = (left+right)/2;
        TreeNode root = new TreeNode(vals[mid]);
        root.left = build(vals,left,mid-1);
        root.right = build(vals,mid+1,right);
        return root;
    }
    
    public int max(TreeNode root)
    {
        if(root == null)
            return 0;
        int left = max(root.left)+1;
        int right = max(root.right)+1;
        return Math.max(left,right);
    }
}
```

### 18.输出单层结点

```java
import java.util.*;

/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class TreeLevel {
    public ListNode getTreeLevel(TreeNode root, int dep) {
        // write code here
        if(root ==null) return null;
        Queue<TreeNode> que =new LinkedList<>();
        int len =0,i;
        que.add(root);
        while(dep >1 && !que.isEmpty())
        {
            len = que.size();
            for(i=0;i<len;i++)
            {
                TreeNode p = que.poll();
                if(p.left != null)
                    que.add(p.left);
                if(p.right != null)
                    que.add(p.right);
            }
            dep--;
        }
        ListNode res = new ListNode(que.poll().val);
        ListNode tem = res;
        while(!que.isEmpty())
        {
            tem.next = new ListNode(que.poll().val);
            tem =tem.next;
        }
        return res;
    }
}
```

### 19.检查是否为BST

```java
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class Checker {
    public boolean checkBST(TreeNode root) {
        // write code here
        Stack<TreeNode> stack =new Stack<TreeNode>();
        TreeNode p = root;
        int pre = 0;
        boolean isFirst = true;
        while(p != null || !stack.isEmpty())
        {
            while(p != null)
            {
                stack.push(p);
                p = p.left;
            }
            p=stack.pop();
            if(isFirst)
            {
                pre = p.val;
                isFirst = false;
            }else if(p.val < pre){
                return false;
            }else{
                pre =p.val;
            }
            p = p.right;
        }
        return true;
    }
}
```

### 20.寻找下一个结点

 

```java
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class Successor {
    public int findSucc(TreeNode root, int p) {
        boolean isFound = false;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode cur = root;
        while(cur!=null||!stack.isEmpty()){
            while(cur!=null){
                stack.add(cur);
                cur = cur.left;
            }
            if(!stack.isEmpty()){
                TreeNode q = stack.pop();
                if(isFound) return q.val;
                else if(q.val==p) isFound = true;
                cur = q.right;
            }
        }
        return -1;
    }      
}
```

### 21.最近公共祖先

```java
import java.util.*;

public class LCA {
    public int getLCA(int a, int b) {
        // write code here
        while(a != b )
        {
            if(a>b)
                a =a/2;
            else
                b =b/2;
        }
        return a;
    }
}
```

### 22.二叉树中和为某一值

 

```java
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    ArrayList<ArrayList<Integer>> list= new ArrayList<ArrayList<Integer>>();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) 
    {
        ArrayList<Integer> list1 = new ArrayList<>();
        getPath(root,target,list1);
        return list;
    }
    
    public void getPath(TreeNode root, int target, ArrayList<Integer> list1)
    {
        if(root == null || target<0) 
            return;
        list1.add(root.val);
        if(target -root.val ==0 && root.left == null && root.right == null)
        {
            list.add(new ArrayList<Integer>(list1));
        }
        getPath(root.left,target-root.val,list1);
        getPath(root.right,target-root.val,list1);
        list1.remove(list1.size()-1);
    }
}
```

### 23.二进制插入

```java
import java.util.*;

public class BinInsert {
    public int binInsert(int n, int m, int j, int i) 
    {
        // write code here
        return n+(m<<j);
    }
}
```

### 24.二进制小数

```java
//利用十进制小数转换为二进制的特点：小数*2
//如果实数大于1，说明小数点后一位是1，如果小于1，说明小数点后一位是0
import java.util.*;

public class BinDecimal {
    public String printBin(double num) 
    {
        // write code here
        StringBuffer sb = new StringBuffer("0.");
        while(num != 0.0)
        {
            if(sb.length() >32 )
                return "Error";
            num *=2;
            if(num>=1)
            {
                sb.append("1");
                num -=1;
            }else{
                sb.append("0");
            }
        }
        return sb.toString();
    }
}
```

### 25.最接近的数

```java
import java.util.*;

public class CloseNumber {
    public int[] getCloseNumber(int x) {
        // write code here
        int min =x-1, max = x+1;
        while(Integer.bitCount(x) != Integer.bitCount(min) && min>=0)
            min--;
        while(Integer.bitCount(x) != Integer.bitCount(max))
            max++;
        int[] arr={min,max};
        return arr;
    }
}
```

### 26.整数转化

```java
import java.util.*;

public class Transform {
    public int calcCost(int A, int B) {
        // write code here
        return Integer.bitCount(A^B);
    }
}
```

### 27.奇偶位交换

```java
import java.util.*;

public class Exchange {
    public int exchangeOddEven(int x) {
        // write code here
        String binStr = Integer.toBinaryString(x);
        if(binStr.length()%2 == 1)
        {
            binStr = "0"+binStr;
        }
        char[] charArr = binStr.toCharArray();
        for(int i=1;i<charArr.length;i+=2)
        {
            char temp = charArr[i-1];
            charArr[i-1] = charArr[i];
            charArr[i] = temp;
        }
        return Integer.valueOf(new String(charArr),2);
    }
}
```

### 28.找出缺失的整数

```java
import java.util.*;

public class Finder {
    public int findMissing(int[][] numbers, int n) {
        // write code here
        int sum1 = (0+n)*(n+1)/2;
        int sum2 =0;
        for(int i=0;i<n;i++)
        {
            int number =0;
            for(int j=0;j<numbers[i].length;j++)
            {
               number = number*2 +numbers[i][numbers[i].length-1-j];
            }
            sum2+=number;
        }
        return sum1-sum2;
    }
}
```

### 29.像素设定

```java
/**
采用最普通的算法一位一位的进行填色，
即0->1,1->1（或）
因此就是要找到当前要填的像素位于数组的那个位置，位于哪个位，
然后进行或运算
*/
import java.util.*;

public class Render {
    public int[] renderPixel(int[] screen, int x, int y) {
        // write code here
        for(int i=x;i<=y;i++)
        {
            int k = i % 8;
            int t = i/8;
            screen[t] = screen[t] | (1<<k);
        }
        return screen;
    }
}
```

### 30.判断直线相交

```java
import java.util.*;

public class CrossLine {
    public boolean checkCrossLine(double s1, double s2, double y1, double y2) {
        // write code here
        double s = Math.abs(s1-s2);
        double y = Math.abs(y1-y2);
        if((s<1e-6) && (y<1e-6))
            return true;
        else if((s<1e-6) && (y>=1e-6))
            return false;
        else
            return true;
    }
}
```

### 31.加法运算替代

```java
import java.util.*;

public class AddSubstitution {
    public int calc(int a, int b, int type) {
        // write code here
        int res = 0;
        switch(type)
        {
            case 1:
                res = mult(a,b);
                break;
            case 0:
                res = div(a,b);
                break;
            case -1:
                res= sub(a,b);
                break;
        }
        return res;
    }
    
    public int mult(int a,int b)
    {
        int r=0;
        for(int i=0;i<a;i++)
        {
            r+=b;
        }
        return r;
    }
    
    public int div(int a,int b)
    {
        for(int i=1;i<=a;i++)
            if(mult(b,i) <=a&&mult(b,i+1)>a)
                return i;
        return 0;
    }
    
    public int sub(int a,int b)
    {
        if(a>=b)
        {
            for(int i=0;i<a;i++)
            {
                if(i+b==a)
                    return i;
            }
        }
        return mult(sub(b,a),-1);
    }
}
```

### 32.平分的直线

```java
import java.util.*;

/*
public class Point {
    int x;
    int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public Point() {
        this.x = 0;
        this.y = 0;
    }
}*/
public class Bipartition {
    public double[] getBipartition(Point[] A, Point[] B) {
        // write code here
        double pointX_A = (A[0].x+A[1].x+A[2].x+A[3].x)/4.0;
        double pointY_A = (A[0].y+A[1].y+A[2].y+A[3].y)/4.0;
        double pointX_B = (B[0].x+B[1].x+B[2].x+B[3].x)/4.0;
        double pointY_B = (B[0].y+B[1].y+B[2].y+B[3].y)/4.0;
        double k = (pointY_A- pointY_B)/(pointX_A-pointX_B);
        double l = pointY_B  - k*pointX_B;
        double[] res =new double[2];
        res[0] = k;
        res[1] = l;
        return res;
    }
}
```

### 33.穿点最多的直线

```java
import java.util.*;

/*
public class Point {
    int x;
    int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public Point() {
        this.x = 0;
        this.y = 0;
    }
}*/
public class DenseLine {
    public double[] getLine(Point[] p, int n) {
        // write code here
        double[] ds = new double[2];
        int max =2;
        int t;
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                double a= (p[i].y-p[j].y)/(p[i].x-p[j].x);
                double b=p[i].y-p[i].x*a;
                t=2;
                for(int z=0;z<n;z++)
                {
                    if(z==i || z==j)
                        continue;
                    if(a == (p[i].y-p[z].y)/(p[i].x-p[z].x))
                    {
                        t++;
                    }
                }
                if(max<t)
                {
                    t=max;
                    ds[0] = a;
                    ds[1] = b;
                }
            }
        }
        return ds;
    }
}
```

###  34.第k个数

```java
import java.util.*;

public class KthNumber {
    public int findKth(int k) 
    {
        // write code here
        int[] array = new int[k];
        int num3=0;
        int num5=0;
        int num7=0;
        array[0] =3;
        array[1] =5;
        array[2]=7;
        for(int i=3;i<k;i++)
        {
            array[i] = Math.min(Math.min(array[num3]*3,array[num5]*5),array[num7]*7);
            if(array[i] == array[num3]*3) num3++;
            if(array[i] == array[num5]*5) num5++;
            if(array[i] == array[num7]*7) num7++;
        }
        return array[k-1];
    }
}
```

### 35.上楼梯

```java
import java.util.*;
/*
思路：上1级有一种，2级上1级后再上1级，3级有上1级之后上2级或上2级之后上1级或直接上3级
4级有1级上3级，2级上2级，3级上1级
总结起来有：f(1)=1,f(2)=2,f(3)=4,f(4)=f(1)+f(2)+f(3);f(5)=f(2)+f(3)+f(4)
f(n)=f(n-1)+f(n-2)+f(n-3);
本来使用递归做的，结果递归做到最后超时了，只好用迭代了；
*/
public class GoUpstairs {
    public int countWays(int n) 
    {
        // write code here
        if(n <1) return 0;
        if(n==1) return 1;
        if(n==2) return 2;
        int[] array = new int[n];
        array[0] =1;
        array[1] = 2;
        array[2] =4;
        for(int i=3;i<n;i++)
        {
            array[i] = ((array[i-1]%1000000007+array[i-2]%1000000007)%1000000007+array[i-3]%1000000007)%1000000007;
        }
        return array[n-1];
    }
}
```

### 36.机器人走方格I

```java
import java.util.*;
/**  动态规划DP
当前子问题的解将由上一次子问题的解推出

*/
public class Robot {
    public int countWays(int x, int y) {
        // write code here
        int[][] dp =new int[x][y];
        dp[0][0] = 1;
        for(int i=1;i<x;i++)
        {
            dp[i][0] = dp[i-1][0];
        }
        for(int i=1;i<y;i++)
        {
            dp[0][i] = dp[0][i-1];
        }
        for(int i=1;i<x;i++)
        {
            for(int j=1;j<y;j++)
            {
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[x-1][y-1];
    }
}
```

### 37.机器人走方格II

```java
import java.util.*;

public class Robot {
    public int countWays(int[][] map, int x, int y) {
    // write code here
    /*
     * 1.判断右下角的点以及起点自身是否为障碍点，若是返回0；
     * 2.若右下角的点非障碍点，判断上面和左边是否为障碍点
     *  1.若全都为障碍点，返回0
     *  2.若一个为障碍点，一个不是，则到该点的路径数等于上一个点的路径数（这是递归的思路）
     * 第2部分可以不用递归，而用循环：
     *  dp[i-1][j-1]表示从(0,0)到(i,j)的方法数，如果(i,j)非1，则为障碍点，对应dp[i-1][j-1]为0
     *  其余情况与一般dp相同
     */
        if(map == null || map.length != x || map[0].length != y){
            return 0;
        }
        if(map[x-1][y-1] != 1 || map[0][0] != 1){//最后一个点为障碍点
            return 0;
        }
        int dp[][] = new int[x][y];
        dp[0][0] = 1;
        for(int i = 1; i < x; i++){
            if(map[i][0] != 1){
                dp[i][0] = 0;
            }else{
                dp[i][0] = dp[i-1][0];
            }
        }
        for(int i = 1; i < y; i++){
            if(map[0][i] != 1){
                dp[0][i] = 0;
            }else{
                dp[0][i] = dp[0][i-1];
            }
        }
        for(int i = 1; i < x; i++){
            for(int j = 1; j < y; j++){
                if(map[i][j] != 1){
                    dp[i][j] = 0;
                }else{
                    dp[i][j] = dp[i-1][j]%1000000007 + dp[i][j-1]%1000000007;
                }
            }
        }
        return (dp[x-1][y-1]%1000000007);
}
}
```

### 38.魔术索引I

```java
import java.util.*;

public class MagicIndex {
    public boolean findMagicIndex(int[] A, int n) 
    {
        // write code here
        if(A == null || A.length !=n || n<=0)
            return false;
        return findMagic(A,0,A.length-1);
    }
    
    public boolean findMagic(int[] A,int begin,int end)
    {
        if(begin > end)
        {
            return false;
        }
        int index = (begin+end)/2;
        if(A[index] == index)
            return true;
        if(index > A[index])
            return findMagic(A,index+1,end);
        else
            return findMagic(A,begin,index-1);
    }
}
```

### 39.魔术索引II

```java
import java.util.*;

public class MagicIndex {
    public boolean findMagicIndex(int[] A, int n) 
    {
        // write code here
        if(A == null || A.length !=n || n<=0)
            return false;
        return findMagic(A,0,n-1);
    }
    
    public boolean findMagic(int[] A,int begin,int end)
    {
        if(begin > end)
        {
            return false;
        }
        int index = (begin+end)/2;
        if(A[index] == index)
            return true;
        return findMagic(A,begin,index-1)||findMagic(A,index+1,end);
    }
}
```

### 40.集合的子集

```java
import java.util.*;

public class Subset {
    public ArrayList<ArrayList<Integer>> getSubsets(int[] A, int n) 
    {
        // write code here
        ArrayList<ArrayList<Integer>> ret = new ArrayList<ArrayList<Integer>>();
        dfs(A,A.length-1,new ArrayList<Integer>(),ret);
        return ret;
    }
    
    public static void dfs(int[] A, int offset, ArrayList<Integer> solution,ArrayList<ArrayList<Integer>> ret)
    {
        for(int i=offset;i>=0;i--)
        {
            solution.add(A[i]);
            dfs(A,i-1,solution,ret);
            solution.remove(solution.size()-1);
        }
        if(solution.size() != 0)
            ret.add(new ArrayList<Integer>(solution));
        if(offset == -1)
            return;
    }
}
```

### 41.字符串排列

```java
import java.util.*;

public class Permutation {
public ArrayList<String> getPermutation(String A) {
    ArrayList<String> list = f(A);
    Collections.sort(list, new Comparator<String>() {
        public int compare(String o1, String o2) {
            return o2.compareTo(o1);
        }
    });
    return list;
}
 
private ArrayList<String> f(String A) {
    ArrayList<String> list = new ArrayList<String>();
    if (A == null || "".equals(A)) { //递归终止条件
        list.add("");
        return list;
    }
    char c = A.charAt(0);
    String l = A.substring(1);
    ArrayList<String> arr = f(l);
    for (String s : arr) {
        for (int i = 0; i <= s.length(); i++) {
            list.add(insert(s, c, i));
        }
    }
    return list;
}
 
public String insert(String s, char b, int i) { //插入字符
    String a = s.substring(0, i);
    String c = s.substring(i, s.length());
    return a + b + c;
}
}
```

### 42.合法括号序列判断

```java
import java.util.*;

public class Parenthesis {
    public boolean chkParenthesis(String A, int n) {
        // write code here
        char[] charr = A.toCharArray();
        int count = 0;
        for(int i=0;i<charr.length;i++)
        {
            if(charr[i] == '(')
            {
                count++;
            }else if(charr[i] == ')')
            {
                count--;
            }else{
                return false;
            }
        }
        if(count == 0)
            return true;
        return false;
    }
}
```

###  43.洪水

```java
import java.util.*;
/*其实最早到达时间久隐含了只能向下或向右走了，经典动态规划问题*/
public class Flood {
    public int floodFill(int[][] map, int n, int m) {
        // write code here\
        if(map == null || map.length != n|| map[0].length != m)
            return -1;
        if(map[0][0] == 1)
            return -1;
        int[][] time = new int[n][m];
        for(int i=1;i<n;i++)
        {
            if(map[i][0] == 1){
                time[i][0] =Integer.MAX_VALUE;
            }else{
                if(time[i-1][0] == Integer.MAX_VALUE){
                    time[i][0] = Integer.MAX_VALUE;
                }else{
                    time[i][0] = time[i-1][0]+1;
                }
            }
        }
        
        for(int j=1;j<m;j++)
        {
            if(map[0][j] == 1)
            {
                time[0][j] = Integer.MAX_VALUE;
            }else{
                if(time[0][j-1] == Integer.MAX_VALUE)
                {
                    time[0][j] =Integer.MAX_VALUE;
                }else{
                    time[0][j] = time[0][j-1]+1;
                }
            }
        }
        
        for(int i=1;i<n;i++)
        {
            for(int j=1;j<m;j++)
            {
                if(time[i-1][j] == Integer.MAX_VALUE && time[i][j-1]==Integer.MAX_VALUE)
                {
                    time[i][j] = Integer.MAX_VALUE;
                }else{
                    time[i][j] = Math.min(time[i-1][j],time[i][j-1])+1;
                }
            }
        }
        return time[n-1][m-1];
    }
}
```

###  44.硬币表示

```java
import java.util.*;

public class Coins {
    public int countWays(int n) {
        // write code here
    int A[] = {1, 5, 10, 25}, dp[][] = new int[A.length][n + 1];
    for (int j = 0; j <= n; j++) {
        dp[0][j] = 1;
    }
    for (int i = 1; i < A.length; i++) {
        for (int j = 0; j <= n; j++) {
            int t = j - A[i];
            if (t >= 0) {
                dp[i][j] = (dp[i - 1][j] + dp[i][t]) % 1000000007;
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[A.length - 1][n];
}
}
```

### 45.n皇后问题

```java
import java.util.*;
 
public class Queens {  // 回溯算法
    public int nQueens(int n) {
        // write code here
        if(n<0) return 0;
        int[][] a=new int[n][n];  //创建网格，默认初始为0
        return process(a, 0, n);
    }
    public int process(int[][] a, int row, int n){
        if(row==n)         // 终止条件， 当递归调用到边缘时返回
            return 1;
        int count=0;       // 记录方法数
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++)     // 清除当前行污染
                a[row][j]=0;
            a[row][i]=1;        // 当前位置放置皇后
            if(isCount(a, row, i, n))      //判断是否合理
                count+=process(a, row+1, n);
        }
        return count;
    }
    public boolean isCount(int[][] a, int row, int col, int n){
        int temp=1;
        while(row-temp>=0){
            if(a[row-temp][col]==1)       //中上位置
                return false;
            if(col-temp>=0 && a[row-temp][col-temp]==1)   //左上
                return false;
            if(col+temp<n && a[row-temp][col+temp]==1)    //右上
                return false;
            temp++;
        }
        return true;
    }
}
```

### 46.堆箱子

```java
public class Box {
    private void swap(int[] array, int x, int y) {
        int temp = array[x];
        array[x] = array[y];
        array[y] = temp;
    }

    public int getHeight(int[] w, int[] l, int[] h, int n) {
    // write code here
    /*
     * 按照宽度从大到小排序，定maxH[i]为从0开始到放入第i-1个箱子（第i-1个一定被放入），满足长宽条件的最大高度
     * 从第1个开始为h[0]，初始maxH[i] = h[i]，tmax记录放入第i-1个箱子时可达到的最大高度
     * 伪码如下：
     * maxH[0] = h[0];
     * res = maxH[0];
     * for i = 1:n
     *  maxH[i] = h[i];
     *  tmax = 0;
     *  for j = i-1 : 0
     *      if l[j] > l[i] && w[j] > w[i]//看能放下当前i箱子的情况下，选择高度最大的那种
     *          tmax = max(tmax, maxH[j]);
     *   maxH[i] += tmax;
     *   res = max(res, maxH[i]);//res仅存到放入第i-1个箱子为止，出现过的高度最大值
     *  end for;
     *  return res;
     */
    if(n <= 0){
        return 0;
    }
    //sort
    for(int i = 0; i < n; i++){
        for(int j = i+1; j < n; j++){
            if(w[i] < w[j]){
                swap(w, i, j);
                swap(l, i, j);
                swap(h, i, j);
            }
        }
    }
    //get height
    int[] maxH = new int[n];
    maxH[0] = h[0];
    int res = maxH[0];
    for(int i = 1; i < n; i++){
        maxH[i] = h[i];
        int tmax = 0;
        for(int j = i-1; j >=0; j--){
            if(w[j] > w[i] && l[j] > l[i]){
                tmax = (tmax > maxH[j])? tmax : maxH[j];
            }
        }
        maxH[i] += tmax;
        res = res > maxH[i] ? res : maxH[i];
    }
    return res;
}
}
```

### 47.约瑟夫问题I

```java
import java.util.*;

public class Joseph {
    public int getResult(int n, int m) {
        // write code here
        LinkedList<Integer> list = new LinkedList<Integer>();
        for(int i=1;i<=n;i++)
        {
            list.add(i);
        }
        int bt = 0;
        while(list.size()>1)
        {
            int delPos = (bt+m-1)%list.size();
            list.remove(delPos);
            bt = delPos % list.size();
        }
        return list.get(0);
    }
}
```

### 48.约瑟夫问题II

```java
import java.util.*;

public class Joseph {
    public int getResult(int n) {
        // write code here
        if(n<1)
            return -1;
        LinkedList<Integer> list = new LinkedList<Integer>();
        int round =2,i,curr =0;
        for(i=1;i<=n;i++)
        {
            list.add(i);
        }
        while(list.size()>1)
        {
            i=0;
            while(list.size()>1 && i<list.size())
            {
                curr = (curr+1)%round;
                if(curr != 1)
                {
                    list.remove(i);
                }else{
                    i++;
                }
            }
            round++;
            curr=0;
            if(list.size()>1)
            {
                int last = list.removeLast();
                list.addFirst(last);
            }
        }
        return list.pop();
    }
}
```

### 49.变位词排序

```java
import java.util.*;

public class SortString {
    public ArrayList<String> sortStrings(String[] str, int n) {
        // write code here
        if(str == null || str.length == 0)
            return null;
        ArrayList<String> list = new ArrayList<String>();
        HashMap<String,String> map = new HashMap<>();
        
        for(String s:str)
        {
            String sChar = insideSort(s);
            if(map.get(sChar) == null || s.compareTo(map.get(sChar))<0){
                map.put(sChar,s);
            }
        }
        list.addAll(map.values());
        Collections.sort(list);
        return list;
    }
    
    public String insideSort(String str)
    {
        char c[] = str.toCharArray();
        Arrays.sort(c);
        return new String(c);
    }
}
```

### 50.元素查找

```java
import java.util.*;

public class Finder {
    public int findElement(int[] A, int n, int x) {
        // write code here
        int left = 0;
        int right = n-1;
        int mid = 0;
        while(left <= right)
        {
            mid = left +(right - left)/2;
            if(A[mid] == x)
            {
                return mid;
            }else if(A[mid] > x)
            {
                // 两种情况，都在一跟折线上，或者mid在左边，x在右边
                if(A[mid]> A[right] && x<A[left])// 左右的情况
                {
                    left = mid+1;
                }else{
                    right = mid-1;
                }
            }else{
                if(x>A[right] && A[mid] < A[left])
                {
                    right = mid-1;
                }else{
                    left = mid+1;
                }
            }
        }
        return -1;
    }
}
```

### 51.找出字符串

```java
import java.util.*;
 
public class Finder {
    public int findString(String[] str, int n, String x) {
        // write code here
        int start=0;
        int end=str.length;
        while(start<=end){
            int mid=(start+end)/2;
            if(str[mid].equals(x)){
                return mid;
            }
            if(str[mid].compareTo(x)>0){
                 end=mid-1;
            }else if(str[mid].compareTo(x)<0){
                start=mid+1;
            }
        }
        return -1;
    }
}
```

### 52.矩阵元素查找

```java
import java.util.*;

public class Finder {
    public int[] findElement(int[][] mat, int n, int m, int x) {
        // write code here
        int[] res = new int[2];
        int x1 =0;
        int y1 = m-1;
        while(x1>=0 && y1>=0 && x1<=n-1 && y1<= m-1)
        {
            if(mat[x1][y1] == x)
            {
                res[0] = x1;
                res[1] = y1;
                break;
            }else if(x > mat[x1][y1])
            {
                x1++;
            }else{
                y1--;
            }
        }
        return res;
    }
}
```

### 53.叠罗汉I

```java
import java.util.*;

public class Stack {
    public int getHeight(int[] men, int n) {
        // write code here
        int[] res = new int[n];
        res[0] = 1;
        int max = 1;
        for(int i=1;i<n;i++)
        {
            res[i] =1;
            for(int j=i-1;j>=0;j--)
            {
                if(men[i]>men[j] && res[j]+1>res[i])
                {
                    res[i] = res[j]+1;
                }
            }
            max = Math.max(res[i],max);
        }
        return max;
    }
}
```

### 54.叠罗汉II

```java
import java.util.*;

public class Stack {
    public int getHeight(int[][] actors, int n) {
        // write code here
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                if(actors[i][0]>actors[j][0])
                {
                    int t = actors[i][0];
                    actors[i][0] = actors[j][0];
                    actors[j][0] = t;
                    t = actors[i][1];
                    actors[i][1] = actors[j][1];
                    actors[j][1] = t;
                }
            }
        }
        int[] res = new int[n];
        res[0] =1;
        int max=1;
        for(int i=1;i<n;i++)
        {
            res[i] = 1;
            for(int j=i-1;j>=0;j--)
            {
                if (actors[i][1] > actors[j][1] && res[j]+1 > res[i])
                {
                     res[i] = res[j] + 1;
                }
            }
            max = Math.max(res[i],max);
        }
        return max;
    }
}
```

### 55.维护x的秩

```java
import java.util.*;

public class Rank {
    public static int[] getRankOfNumber(int[] A, int n) {
        // write code here
        int[] result = new int[n];
        for(int i=1;i<n;i++){
            int count =0;
            for(int j=0;j<i;j++){
                if(A[j]<A[i]){
                    count++;
                }
            }
            result[i] = count;
        }
        return result;
    }
}
```

### 56.数组中的逆序对

```java
import java.util.*;

public class AntiOrder {
    public int count(int[] A, int n) {
        // write code here
        int count = 0;
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                if(A[i]>A[j])
                    count++;
            }
        }
        return count;
    }
}
```

### 57.无缓存交换

```java
import java.util.*;

public class Exchange {
    public int[] exchangeAB(int[] AB) {
        // write code here
         AB[0] = AB[0] ^ AB[1];
         AB[1] = AB[0] ^AB[1];
         AB[0] = AB[0] ^AB[1];
        return AB;
    }
}
```

### 58.井字棋

```java
import java.util.*;

public class Board {
    public boolean checkWon(int[][] a) {
        // write code here
       if(a[0][0]+a[1][1]+a[2][2]==3) return true;
       if(a[0][2]+a[1][1]+a[2][0]==3) return true;
       for(int i=0;i<3;i++){
            if(a[i][0]+a[i][1]+a[i][2]==3) return true;
            if(a[0][i]+a[1][i]+a[2][i]==3) return true;
       }
       return false;
    }
}
```

### 59.无判断max

```java
import java.util.*;

public class Max {
    public int getMax(int a, int b) {
        // write code here
        int c = (a-b)>>31;
        return a+c*(a-b);
    }
}
```

### 60.珠玑妙算

```java
import java.util.*;

public class Result {
    public int[] calcResult(String A, String guess) {
        // write code here
        if(A == null || guess == null)
            return new int[]{0,0};
        int right =0,unright=0;
        HashMap<Character,Integer> map = new HashMap<>();
        
        for(int i=0;i<A.length();i++)
        {
            if(A.charAt(i) == guess.charAt(i))
                right++;
            Integer val = map.get(A.charAt(i));
            if(val == null){
                val = 1;
            }else{
                val++;
            }
            map.put(A.charAt(i),val);
        }
        

         for(int i=0;i<guess.length();++i){
                Integer val = map.get(guess.charAt(i));
                if(val != null && val >0){
                    unright++;
                    val--;
                    if(val<0)
                        val=0;
                    map.put(guess.charAt(i), val);
                }
        }
        // 从伪猜中当中，去除猜中个数
        unright -=right;
        if(unright<0)unright = 0;
        return new int[] { right, unright };
    }
}
```

### 61.阶乘尾零

```java
import java.util.*;

public class Factor {
    public int getFactorSuffixZero(int n) {
        // write code here
        int count = 0;
        for(int i=1;i<=n;i++)
        {
            int j=i;
            while(j%5 == 0)
            {
                count++;
                j/=5;
            }
        }
        return count;
    }
}
```

### 62.最小调整有序

```java
import java.util.*;

public class Rearrange {
    public int[] findSegment(int[] A, int n) {
        // write code here
        int[] b ={0,0};
        int[] c = new int[n];
        if(n<=1) return b;
        for(int )
    }
}
```

### 63.数字发音

```java
import java.util.*;
 
public class ToString {
 
    private String[] digits = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"};
    private String[] teens = {"ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    private String[] tens = {"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    private String[] bits = {"", "Thousand", "Million", "Billion"};
 
    public String toString(int x) {
        String str = "";
        int index = 0;
        while (x > 0) {
            if (!str.equals("")) {
                str = dealCore(x % 1000, index) + "," + str;
            } else {
                str = dealCore(x % 1000, index);
            }
            x /= 1000;
            index++;
        }
        return str.trim();
    }
 
    private String dealCore(int n, int index) {
        String str = "";
        if (n / 100 > 0) {
            str = digits[n / 100] + " Hundred ";
            n %= 100;
        }
        if (n / 10 > 0) {
            if (10 <= n && n < 20) {
                str = str + teens[n - 10] + " ";
            } else {
                str = str + tens[n / 10] + " ";
                n %= 10;
                if (n > 0) {
                    str = str + digits[n] + " ";
                }
            }
            n = 0;
        }
        if (n > 0) {
            str = str + digits[n] + " ";
        }
        if (!str.equals("")) {
            str += bits[index];
        }
        return str;
    }
}
```

### 64.最大连续数列和

```java
import java.util.*;

public class MaxSum {
    public int getMaxSum(int[] A, int n) {
        // write code here
        int cur_sum = 0, max_sum =Integer.MIN_VALUE;
        for(int i=0;i<n;i++)
        {
            cur_sum += A[i];
            if(cur_sum > max_sum)
                max_sum = cur_sum;
            if(cur_sum < 0 )
                cur_sum = 0;
        }
        return max_sum;
    }
}
```

### 65.词频统计

```java
import java.util.*;

public class Frequency {
    public int getFrequency(String[] article, int n, String word) {
        // write code here
        int count = 0;
        for(int i=0;i<n;i++)
        {
            if(article[i].equals(word))
                count++;
        }
        return count;
    }
}
```

### 66.整数对查找

```java
import java.util.*;

public class FindPair {
    public int countPairs(int[] A, int n, int sum) {
        // write code here
        int count = 0;
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                if(A[i]+A[j] == sum)
                {
                    count++;
                }
            }
        }
        return count;
    }
}
```

### 67.树转链表

```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class Converter {
    private ListNode head = new ListNode(-1);
    private ListNode q = head;
    public ListNode treeToList(TreeNode root) {
        // write code here
        if(root != null)
        {
            treeToList(root.left);
            q.next = new ListNode(root.val);
            q=q.next;
            treeToList(root.right);
        }
        return head.next;
        
    }
}
```

### 68.另类加法

```java
import java.util.*;

public class UnusualAdd {
    public int addAB(int A, int B) {
        // write code here
        // （A&B）<<1是求得的进位
        if(B != 0)
        {
            int a = A^B;
            int b = (A&B)<<1;
            return addAB(a,b);
        }else{
            return A;
        }
    }
}
```

### 69.2的个数

```java
import java.util.*;

public class Count2 {
    public int countNumberOf2s(int n) {
        // write code here
        int count = 0;
        for (int i = 1; i <= n; i *= 10) {
        int a = n / i,b = n % i;
        //之所以补7，是因为当百位为0，则a/10==(a+7)/10，
        //当百位>=3，补7会产生进位位，效果等同于(a/10+1)
        count += (a + 7) / 10 * i + ((a % 10 == 2) ? b + 1 : 0);
    }
    return count;
    }
}
```

### 70.下一个较大元素

```java
import java.util.*;

public class NextElement {
    public int[] findNext(int[] A, int n) {
        // write code here
        Stack<Integer> stack = new Stack<Integer>();
        for(int i=0;i<A.length;i++)
        {
            while(!stack.isEmpty() && A[stack.peek()]<A[i])
            {
                A[stack.pop()] = A[i];
            }
            stack.add(i);
        }
        while(!stack.empty())
            A[stack.pop()] =-1;
        return A;
    }
}
```

### 71.下一个较大元素II

```java
import java.util.*;

public class NextElement {
    public int[] findNext(int[] A, int n) 
    {
        // write code here
        if(A == null || A.length==0) return null;
        Stack<Integer> stack1 =new Stack<>();//将stack1作为主栈
        Stack<Integer> stack2 =new Stack<>();//将stack2作为辅助栈
        int b[] =new int[n];
        for(int end =n-1;end>=0;end--){
            //最麻烦的一环，如果大于栈顶的元素，那就应该将栈顶的元素放入辅助栈中
            //继续比较，直到小于栈顶元素或者主栈为空
            //这个应该放在第一个作判断
            while(!stack1.isEmpty()&&A[end]>=stack1.peek()){
                stack2.push(stack1.pop());
            }
            //如果小于栈顶的元素，即小于栈中最小元素
            //栈为空这个判断放到最后比较合理
            //还要记得把辅助栈内的数据导回到主栈中
            if(stack1.isEmpty()){
                stack1.push(A[end]);
                b[end]=-1;
            }else{
                b[end] =stack1.peek();
                stack1.push(A[end]);
            }
             while(!stack2.isEmpty()){
                    stack1.push(stack2.pop());
                }
        }
        return b;
        
    }
}
```

### 72.单词最近距离

```java
import java.util.*;

public class Distance {
    public int getDistance(String[] article, int n, String x, String y) {
        // write code here
        int startX = -1, endY =-1;
        int minD = Integer.MAX_VALUE;
        for(int i=0;i<article.length;i++)
        {
            if(article[i].equals(x))
                startX = i;
            else if(article[i].equals(y))
                endY = i;
            else
                continue;
            if(startX != -1 && endY != -1)
                minD = Math.min(Math.abs(startX-endY),minD);
        }
        return minD;
    }
}
```

### 73.最长合成字符串

```java
import java.util.*;

public class LongestString {
    public int getLongest(String[] str, int n) {
        // write code here
        if(n == 0) return 0;
        Arrays.sort(str);
        int maxLen =1;
        for(int i=0;i<n;i++)
        {
            if(getLongestCore(str, str[i], n, i, 0)) maxLen = Math.max(maxLen, str[i].length());
        }
        return maxLen;
    }
    
    private boolean getLongestCore(String[] str, String s,int n,int strIdx,int start)
    {
        if(start>=n) return true;
        for(int i=0;i<strIdx;i++)
        {
            if(s.indexOf(str[i]) == 0)
            {
                return getLongestCore(str, s, n, strIdx, start + str[i].length());
            }
        }
        return false;
    }
}
```

### 74.子串判断

```java
import java.util.*;

public class Substr {
    public boolean[] chkSubStr(String[] p, int n, String s) {
        // write code here
        boolean[] res = new boolean[n];
        for(int i=0;i<p.length;i++)
        {
            res[i] = isSubStr(p[i],s);
        }
        return res;
    }
    
    public boolean isSubStr(String sub,String s)
    {
        if(s.indexOf(sub) != -1)
            return true;
        else
            return false;
    }
}
```

### 75.实时中位数

```java
import java.util.*;

public class Middle {
    public int[] getMiddle(int[] A, int n) {
        // write code here
        int[] res = new int[A.length];
        res[0] = A[0];
        for(int i=1;i<A.length;i++)
        {
            int k=i-1;
            int tem = A[i];
            while(k>=0 && A[k]>tem)
            {
                A[k+1] = A[k];
                k--;
            }
            A[++k] = tem;
            res[i] = A[i/2];
        }
        return res;
    }
}
```

### 76.字符串变换

```java
import java.util.*;

public class Change {
public int countChanges(String[] dic, int n, String s, String t) {
        // write code here
        if(dic==null || n==0){
            return 0;
        }       
        HashSet<String> hash=new HashSet();  //记录访问过的string,同时可以判断某个string是否访问过
        Queue<String> queue=new LinkedList<String>();
        queue.offer(s);
        hash.add(s);
        int length=0; // 从0开始
        while(!queue.isEmpty()){
            length++;  // 每进入循环一次，即步长+1
            int size=queue.size();
            for(int i=0;i<size;i++){  // 同一个level
                String curr = queue.poll();
                for(String next: getNext(curr,dic)){ // 满足条件的变换了的字符串
                    if(hash.contains(next)){
                        continue;
                    }                   
                    if(next.equals(t)){  //找到t字符串了就return
            return length;
                    }
                     
                    queue.offer(next); // 继续下一步的查找
                    hash.add(next);
                }
            }
        }
         
        return 0;
    }
     
    private List<String> getNext(String word, String[] dic){
        List<String> result=new ArrayList<String>();
        if(dic==null || dic.length==0) return result;
        Set<String> set=new HashSet<String>();  //由于dic中有重复的字符串，使用HashSet来去掉重复的
        for(String s:dic){
            set.add(s);
        }       
        for(char ch='a';ch<='z';ch++){
            for(int i=0;i<word.length();i++){
                if(word.charAt(i)==ch){
                    continue;
                }
                 
                String newWord=replace(word,i,ch);
                if(set.contains(newWord)){
                    result.add(newWord);
                }
            }
        }       
        return result;
    }
     
    private String replace(String s,int i, char ch){
        char[] arr=s.toCharArray();
        arr[i]=ch;
        return new String(arr);
    }
}
```

### 77.最大子方阵

```java
import java.util.*;
 
public class SubMatrix {
    public int maxSubMatrix(int[][] mat, int n) {
        // write code here
        for(int size = n ; size>=1;size--)
        for(int row = 0;row< n ;row++){
            for(int col =0;col< n ;col++){
                if(isSquare0(mat,row,col,size) || isSquare1(mat,row,col,size)){
                    return size;
                }
            }
        }
        return -1;
    }
    // 第row 行 col列 （0开始） 开始的矩阵，矩阵大小是 size
    public boolean isSquare0(int[][] mat, int row, int col,int size){
        // 检查 上 下 边界
        for(int j = 0; j < size; j++){
            if(col+j>=mat.length || row+size-1>=mat.length)
                return false;
            if(mat[row][col+j] == 1)
                return false;
            if(mat[row+size-1][col+j] ==1)
                return false;
        }
        // 检测 左 右 边界
        for(int i = 0;i< size - 1;i++){
            if(row+i>=mat.length || col+size-1>=mat.length)
                return false;
            if( mat[row+i][col] == 1)
                return false;
            if(mat[row+i][col+size-1]==1)
                return false;
        }
        return true;
    }
    public boolean isSquare1(int[][] mat, int row, int col,int size){
        // 检查 上 下 边界
        for(int j = 0; j < size; j++){
            if(col+j>=mat.length || row+size-1>=mat.length)
                return false;
            if(mat[row][col+j] == 0)
                return false;
            if(mat[row+size-1][col+j] ==0)
                return false;
        }
        // 检测 左 右 边界
        for(int i = 0;i< size - 1;i++){
            if(row+i>=mat.length || col+size-1>=mat.length)
                return false;
            if( mat[row+i][col] == 0)
                return false;
            if(mat[row+i][col+size-1]==0)
                return false;
        }
        return true;
    }
     
}
```

### 78.最大和子矩阵

```java
import java.util.*;
 
public class SubMatrix {
    public int sumOfSubMatrix(int[][] mat, int n) {
       int max = Integer.MIN_VALUE;
        for(int i = 0; i < n; i++) {
            int[] temp = mat[i];
            max = Math.max(max, helper(temp));
            for(int j = i+1; j < n; j++) {
                for(int k = 0; k < n; k++) {
                    temp[k] += mat[j][k];
                }
                max = Math.max(max, helper(temp));
            }
             
        }
        return max;
    }`
    int helper(int[] a) {
        int temp = a[0];
        int maxVal =temp;
        for(int i = 1; i < a.length; i++) {
            if(temp < 0) {
                temp = a[i];
            }else {
                temp += a[i];
            }
             
            maxVal = temp > maxVal? temp : maxVal;
        }
        return maxVal;
    }
}
```

### 79.最大字母矩阵

```
import java.util.*;
 
public class AlphaMatrix {
    public int findAlphaMatrix(String[] dic, int n) {
        // write code here
        if(n < 1)
            return 0;
        int res = 0;
        HashMap<String,Integer> map = new HashMap<>();
        for(int i = 0; i < n ; i++) {
            if(map.containsKey(dic[i])) {
                map.put(dic[i], map.get(dic[i]) + 1);
                res = Math.max(res, map.get(dic[i]) * dic[i].length());
            }else {
                map.put(dic[i], 1);
                res = Math.max(res, dic[i].length());
            }
        }
        return res;
    }
}
```

