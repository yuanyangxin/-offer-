

[TOC]



## **数据结构定义**

```python
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class DoubleNode(object):
    def __init__(self, key, val, pre=None, next=None):
        self.key = key
        self.val = val
        self.pre = pre
        self.next = next


# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```



## **单例模式**

```java
// 饿汉
class Single{
    private static final Single s = new Single();
    private Single(){}
    public static Single getInstance(){
        return s;
    }
}

//懒汉
class Single{
    private static  Single s = null;
    private Single(){}
    public static Single getInstance(){
        if(null==s) {
            s = new Single();
        }
        return s;
    }
}


// 双重检验锁
class Single{
    private static volatile Single s = null;
    private Single(){}
    public static Single getSingle(){
        if(s == null){
            synchronized(Single.class){
                if(s == null){
                    s = new Single();
                }
            }
        }
        return s;
    }
}
```



## **三个线程循环打印 ABC 10 次**

```java
// 使用Semaphore 信号量实现，获取用semphore.acquire()消费一个使用许可
// release()创建一个消费许可
import java.util.concurrent.Semaphore;
 
public class ThreeThread {
    private static Semaphore semaphoreA = new Semaphore(1);
    private static Semaphore semaphoreB = new Semaphore(0);
    private static Semaphore semaphoreC = new Semaphore(0);
 
    static class  printDemo{
        public void printA(){
            print('A', semaphoreA, semaphoreB);
        }
 
        public void printB(){
            print('B', semaphoreB, semaphoreC);
        }
 
        public void printC(){
            print('C',semaphoreC, semaphoreA);
        }
 
        private void print(char name, Semaphore semaphore, Semaphore nextSemphore)
        {
            for (int i = 0;i < 10; i++){
                try {
                    semaphore.acquire();
                    System.out.println(name + " i:" + i);
                    nextSemphore.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
 
            }
        }
    }
 
    public static void main(String[] args) {
        final printDemo printDemo = new printDemo();
        new Thread(){
            @Override
            public void run(){
                printDemo.printA();
            }
        }.start();
 
        new Thread(){
            @Override
            public void run(){
                printDemo.printB();
            }
        }.start();
 
        new Thread(){
            @Override
            public void run(){
                printDemo.printC();
            }
        }.start();
    }
 
}
```





## **排序算法**



### **快排**

```python
def swap(nums, i, j):
    nums[i], nums[j] = nums[j], nums[i]

def quickSort(nums, low, high):
    if len(nums) <= 0:
        return
    if low >= high:
        return
    left, right = low, high
    temp = nums[low]
    while left < right:
        while left < right and nums[right] > temp:
            right -= 1
        while left < right and nums[left] <= temp:
            left += 1
        swap(nums, left, right)
    swap(nums, left, low)
    quickSort(nums, low, left - 1)
    quickSort(nums, left + 1, high)
```



### **归并**

```python
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    L = [0] * n1
    R = [0] * n2
    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    i = 0
    j = 0
    k = l
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
    while i < n1:
        arr[k] = L[i]
        k += 1
        i += 1
    while j < n2:
        arr[k] = R[j]
        k += 1
        j += 1

def mergeSort(arr, l, r):
    if l < r:
        m = (l + r) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
```



### **堆**

```
def get_max_heap(heap, size, root):  # 在堆中做结构调整使得父节点的值大于子节点
    left = 2 * root + 1
    right = left + 1
    larger = root
    if left < size and heap[larger] < heap[left]:  # 保证最大值不会被重新排序
        larger = left
    if right < size and heap[larger] < heap[right]:  # 保证最大值不会被重新排序
        larger = right
    if larger != root:  # 如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作
        heap[larger], heap[root] = heap[root], heap[larger]
        get_max_heap(heap, size, larger)


def build_heap(heap):
    # 构造一个堆，将堆中所有数据重新排序
    for index in range(len(heap) // 2 - 1, -1, -1):  # 从第一个非叶子节点开始
        get_max_heap(heap, len(heap), index)


def sort(heap):
    build_heap(heap)  # 获得一个大顶堆
    for index in range(len(heap) - 1, -1, -1):
        heap[0], heap[index] = heap[index], heap[0]  # 将最大值调到最后
        get_max_heap(heap, index, 0)  # size递减，保证最大值不会被重新排序
    return heap

arr = [2,1,5,6,3,1100,200]
print(sort(arr))
```



## **数学**

### **二进制中1的个数**

n&(n-1) 消除最低位的1（n为负数的时候有问题），用正常的位移运算解决。
int的取值范围-2^31 - 2^31-1，因此range(0,32)

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        count= 0
        for i in range(0,32):
            if n&1==1:
                count+=1
            n>>=1
        return count
```



###  **数值的整数次方**

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n==0:
            return 1
        if n == 1:
            return x
        exponent = abs(n)
        res = 1
        res = self.myPow(x * x, exponent//2)
        if exponent % 2 == 1:
            res = res*x
        return res if n>=0 else 1/res
```



### **求质数**

统计所有小于非负整数 n 的质数的数量。

```python
class Solution(object):
    def countPrimes(self, n):
        """
        :type n: int
        :rtype: int
        """
        isPrimes = [1] * n
        res = 0
        for i in range(2, n):
            if isPrimes[i] == 1:
                res += 1
            j = i
            while i * j < n:
                isPrimes[i * j] = 0
                j += 1
        return res
```



### **用 Rand7() 实现 Rand10()**

```python
class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        n=rand7()
        while n>5:
            n=rand7()
        i=rand7()
        while i==4:
            i=rand7()
        if i<4:
            j=0
        else:
            j=5
        return n+j
```



### **逆波兰表达式求值**

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        PopList = []
        for i in tokens:
            if i in "+-*/":
                value1 = PopList.pop()
                value2 = PopList.pop()
                PopList.append(str(int(eval(value2+i+value1))))
            else:
                PopList.append(i)
        return int(PopList[0])
```



###  **1～n整数中1出现的次数**

```python
class Solution(object):
    def countDigitOne(self, n):
        """
        :type n: int
        :rtype: int
        把1~n的个位，十位，百位...1的出现次数相加，即为1出现的总次数
        (1) cur == 0
            2304,23为high， 0为cur， 4为low，digit在十位=10
            0010 - 2219 十位出现1
            十位舍去后统计 000-229
            1的个数：high * digit
        (2) cur == 1
            2314,23为high， 1为cur， 4为low，digit在十位=10
            0010 - 2314 十位出现1
            十位舍去后统计： 000-234  共235
            1的个数：high*digit + low + 1
        (3) cur > 2
            2324, 23为high， 2为cur， 4为low，digit在十位=10
            0010 - 2319 十位出现1
            十位舍去后统计： 000-239 
            1的个数： (high + 1)*digit
        """
        digit, res = 1, 0
        high, cur, low = n//10, n % 10, 0

        while high != 0 or cur != 0:
            if cur == 0:
                res += high * digit
            elif cur == 1:
                res += high * digit + low + 1
            else:
                res += (high + 1) * digit 
            low += cur*digit 
            cur = high % 10
            high //= 10
            digit *= 10
        return res
```



### **x 的平方根**

```python
class Solution(object):
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。
        """
        l, r, ans = 0, x, -1
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x:
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
        return ans
```



### **0-1背包，不可分割**

有n 个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？

```python
number, capacity = 4, 8
w = [0, 2, 3, 4, 5]
v = [0, 3, 4, 5, 6]
dp = [[0] * (capacity + 1) for _ in range(number + 1)]
for i in range(number + 1):
    for j in range(capacity + 1):
        if i == 0:
            dp[i][j] = 0
        elif j == 0:
            dp[i][j] = 0
        else:
            if j < w[i]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i - 1][j - w[i]] + v[i])
 
print(dp)
print(dp[number][capacity])
```



### **完全背包问题**

有n种物品(每个物品无限个)和容量为m的背包 给出n件物品的重量以及价值 求解让装入背包的物品重量不超过背包容量 且价值最大 。

```python
number, capacity = 3, 5
w = [0, 3, 2, 2]
v = [0, 5, 10, 20]
dp = [[0] * (capacity + 1) for _ in range(number + 1)]
for i in range(number + 1):
    for j in range(capacity + 1):
        if i == 0:
            dp[i][j] = 0
        elif j == 0:
            dp[i][j] = 0
        else:
            nCount = j // w[i]
            for k in range(nCount + 1):
                dp[i][j] = max(dp[i][j], dp[i-1][j - k*w[i]] + k * v[i])
 
print(dp)
print(dp[number][capacity])
```



### **背包问题可分割**

n种宝物，每种宝物有一定重量h和对应价值v，毛驴可运m重量的宝物，宝物可分割，如何使宝物价值最大？

```python
m = eval(input('可承载的最大重量：'))
h = eval(input('宝物重量：'))
v = eval(input('宝物价值：'))
  
# 计算权重, 整合得到一个数组
arr = [(i,v[i]/h[i], h[i], v[i]) for i in range(len(h))]
  
# 按照list中的权重，从大到小排序
arr.sort(key=lambda x:x[1], reverse=True)  # list.sort() list排序函数
  
bagVal = 0
bagList = []
for i,w,h,v in arr:
    # 1 如果能放的下宝物，那就把宝物全放进去
    if w <= m:
        m -= h
        bagVal += v
        bagList.append(i)
     
    # 2 如果宝物不能完全放下，考虑放入部分宝物
    else:
        bagVal += m * w
        bagList.append(i)
        break
  
print('\n排序后：',arr)
print('能运走的最大价值：%.2f'%bagVal,'此时承载的宝物有：',bagList)

```



### **电话号码的字母组合**

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```
class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        回溯法
        """
        if not digits:
            return []
        phone = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }

        def backTracking(index):
            if index == len(digits):
                combinations.append("".join(combination))
            else:
                digit = digits[index]
                for letter in phone[digit]:
                    combination.append(letter)
                    backTracking(index + 1)
                    combination.pop()
        combination = []
        combinations = []
        backTracking(0)
        return combinations
```











## **字符串**

### **无重复字符的最长子串**

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度

```python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        if not s:
            return 0
        count = {}
        maxLen = 0
        i,j = 0,0
        length = len(s)
        while i<length and j<=length:
            if j<length and s[j] not in count:
                count[s[j]] = 1
                j+=1
            else:
                maxLen = max(maxLen,(j-i))
                del count[s[i]]
                i += 1
        return maxLen
```

 

### **最长公共前缀**

编写一个函数来查找字符串数组中的最长公共前缀。

```python
class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        if len(strs) == 0 or not strs:
            return ""

        first = strs[0]
        for i in range(0,len(first)):
            c = first[i]
            for j in range(1,len(strs)):
                if i >= len(strs[j]) or strs[j][i] != c:
                    return first[0:i]
        return first
```



###  **最长回文子串**

```python
class Solution(object):
    def expand(self, s, left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return left + 1, right - 1


    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        中心扩展算法
        """
        start, end = 0, 0
        for i in range(len(s)):
            left1, right1 = self.expand(s, i, i)
            left2, right2 = self.expand(s, i, i + 1)
            if right1 - left1 > end - start:
                start, end = left1, right1
            if right2 - left2 > end - start:
                start, end = left2, right2
        return s[start: end + 1]        
```









### **字符串的排列**

输入一个字符串，打印出该字符串中字符的所有排列。

```python
class Solution(object):
    def helper(self, res, s, start):
        if start == len(s):
            res.add(''.join(s))
            return 

        for i in range(start, len(s)):
            s[start], s[i] = s[i], s[start]
            self.helper(res, s, start+1)
            s[start], s[i] = s[i], s[start]

    def permutation(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        res = set()
        if not s:
            return []
        self.helper(res, list(s), 0)
        return sorted(list(res))
```





### **字符串相乘**

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

```python
class Solution(object):
    def multiply(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        length = len(num1) + len(num2) - 1
        result = [0] * length
        if num1 == '0' or num2 == '0':
            return '0'

        for i in range(len(num1)):
            for j in range(len(num2)):
                result[i + j] += int(num1[i]) * int(num2[j])

        res = ""
        carry = 0
        for i in range(len(result)-1, -1, -1):
            result[i] += carry
            carry = result[i] // 10
            result[i] %= 10
            res += str(result[i])
        if carry != 0:
            res += str(carry)
        return res[::-1]
```



### **简化路径**

以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。

```python
class Solution(object):
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """
        paths = path.split('/')
        stack = []
        for i in paths:
            if i == "..":
                if stack:
                    stack.pop()
            elif i == '.' or i == '':
                continue
            else:
                stack.append(i)
        return '/' + '/'.join(stack)
```





### **复原IP地址**

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式.



```python
class Solution(object):
    def checkIp(self, s, left, right):
        size = right - left + 1

        if size > 1 and s[left] == '0':
            return -1
        
        res = 0
        for i in range(left, right + 1):
            res = res * 10 + int(s[i])
        
        if res > 255:
            return -1
        return res 

    def helper(self, s, size, split_times, begin, path, res):
        if begin == size:
            if split_times == 4:
                res.append('.'.join(path))
            return
        
        if size - begin < (4 - split_times) or size - begin > 3 * (4-split_times):
            return
        
        for i in range(3):
            if begin + i >= size:
                break
            ip_segment = self.checkIp(s, begin, begin+i)

            if ip_segment != -1:
                path.append(str(ip_segment))
                self.helper(s, size, split_times+1, begin + i + 1, path, res)
                path.pop()

    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        size = len(s) 
        if size < 4 or size > 12:
            return []
        path, res = [], []
        self.helper(s, size, 0, 0, path, res)
        return res
```

 

### **验证IPv4或者IPv6地址**

```python
class Solution(object):
    def validIPAddress(self, IP):
        """
        :type IP: str
        :rtype: str
        IPv4：
            段地址数只能为4；
            以0开头时只允许长度为1；
            段地址必须是可以进行int()的字符串；
            int()之后必须在[0,255]区间；
        IPv6：
            段地址数只能为8；
            段地址只允许长度为[1,4]区间；
            段地址每个字符必须是合法的16进制字符，例如G不合法；
        """
        if '.' in IP:
            ips = IP.split('.')
            if len(ips) != 4:
                return "Neither"
            for a in ips:
                try:
                    if a.startswith('0') and len(a) != 1:
                        return "Neither"
                    elif int(a) < 0 or int(a) > 255:
                        return "Neither"
                except:
                    return "Neither"
            return "IPv4"
        elif ':' in IP:
            ips = IP.split(":")
            if len(ips) != 8:
                return "Neither"
            for a in ips:
                if len(a) == 0 or len(a) > 4:
                    return "Neither"
                for aa in a:
                    if aa not in '0123456789abcdefABCDEF':
                        return "Neither"
            return "IPv6"
        return "Neither"
```









### **字符串相加**

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

```python
class Solution(object):
    def addStrings(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        if not num1 and not num2:
            return ""
        if not num1:
            return num2
        if not num2:
            return num1
        
        number1 = num1[::-1]
        number2 = num2[::-1]

        carry = 0
        result = ""

        while number1 and number2:
            n1 = int(number1[0])
            n2 = int(number2[0])
            number1 = number1[1:]
            number2 = number2[1:]

            res = n1 + n2 + carry

            if res < 10:
                result += str(res)
                carry = 0
            else:
                carry = 1 
                result += str(res - 10)
        
        while number1:
            n1 = int(number1[0])
            number1 = number1[1:]
            res = n1 + carry
            if res < 10:
                result += str(res)
                carry = 0
            else:
                result += str(res - 10)
                carry = 1
        
        while number2:
            n2 = int(number2[0])
            number2 = number2[1:]
            res = n2 + carry
            if res < 10:
                result += str(res)
                carry = 0
            else:
                result += str(res - 10)
                carry = 1
        
        if carry:
            result += "1"
        return result[::-1]
```

 

 

### **段式回文**

```python
class Solution:
    def longestDecomposition(self, text: str) -> int:
        n = len(text)
        i, pre_i = 0, -1
        ans = 0
        j = n - 1
        while i <= j:
            while i <= j and text[i] != text[j]:
                i += 1
            if i == j:
                ans += 1
                break
            elif i < j:
                l = i - pre_i
                flag = True
                for k in range(l):
                    if text[j - k] == text[i - k]:
                        continue
                    else:
                        flag = False
                        break
                if flag:
                    pre_i = i 
                    i += 1
                    j = j -l 
                    ans += 2
                else:
                    i += 1
            else:
                break
        return ans
```

 

### 可以删除一个字符判断是不是回文字符串

```python
#680
class Solution:
    def judgestr(self,s,i,j):
        while i<j:
            if s[i] != s[j]:
                return False
            i+=1
            j-=1
        return True
        
    def validPalindrome(self, s: str) -> bool:
        i, j = 0,len(s)-1
        count = 0
        while i<j:
            if s[i] != s[j]:
                if self.judgestr(s,i+1,j) or self.judgestr(s,i,j-1):
                    return True
                else:
                    return False
            i+=1
            j-=1
                
        return True
```



### **有效的括号**

```python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if not s or len(s) == 0:
            return True
        stack = []
        for i in s:
            if i == '(':
                stack.append(')')
            elif i == '[':
                stack.append(']')
            elif i == '{':
                stack.append('}')
            else:
                if stack and i == stack[-1]:
                    stack.pop()
                    continue
                else:
                    return False
        return len(stack) == 0
```



### **生成所有可能的并且有效的括号组合**

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合

```python
class Solution(object):
    def helper(self, res, s, left, right):
        if left > right:
            return
        if left == 0 and right == 0:
            res.append(s)
            return
        if left > 0:
            self.helper(res, s + "(", left - 1, right)
        if right > 0:
            self.helper(res, s + ")", left, right - 1)

    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        res = []
        if n == 0:
            return res
        self.helper(res, "", n, n)
        return res
```







### **正则表达式匹配**

使用递归来做

```python
#请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        if not p: return not s
        # 第一个字母是否匹配
        first_match = bool(s and p[0] in {s[0],'.'})
        # 如果 p 第二个字母是 *
        if len(p) >= 2 and p[1] == "*":
            return self.isMatch(s, p[2:]) or (first_match and self.isMatch(s[1:], p))
        else:
            return first_match and self.isMatch(s[1:], p[1:])
```



### **通配符匹配**

```python
class Solution(object):
    def isMatch(self, s, p):
        """
        给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
        :type s: str
        :type p: str
        :rtype: bool
        动态规划做：
            1. dp[i][j] = dp[i-1][j-1] si与pj相同 或者 pj是问号
            2. dp[i][j] = dp[i][j-1] 或 dp[i-1][j] pj是*号
            3. dp[i][j] = False 其他情况
        """
        m, n = len(s), len(p)

        dp = [[False] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = True
        for i in range(1, n + 1):
            if p[i - 1] == '*':
                dp[0][i] = True
            else:
                break
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                
        return dp[m][n]
```







### **表示数值的字符串（包括整数和小数）**

字符串"+100"、"5e2"、"-123"、"3.1416"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"、"-1E-16"及"12e+5.4"都不是。

```python
class Solution:
    def __init__(self):
        self.p =0

    def scanInteger(self,s):
        if s[self.p] in ['+','-']:
            self.p+=1
        return self.scanUnsignedInteger(s)

    def scanUnsignedInteger(self,s):
        pre = self.p
        while(self.p<len(s) and s[self.p] >= '0' and s[self.p] <='9'):
            self.p+=1
        return self.p>pre

    def isNumber(self, s: str) -> bool:
        s = s.strip()
        if s=='':
            return False
        number = self.scanInteger(s)

        if self.p >len(s)-1:
            return number
        
        if self.p < len(s) and s[self.p] =='.':
            self.p +=1
            if self.p > len(s)-1:
                return number
            number = self.scanUnsignedInteger(s) or number
        
        if self.p<len(s) and s[self.p] in ['e','E']:
            self.p+=1
            if self.p >len(s)-1:
                return False
            number = number and self.scanInteger(s)
        
        if self.p <len(s):
            return False
        
        return number
```



### **计算具有相同数量0和1的非空(连续)子字符串的数量**

给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

```python
class Solution(object):
    def countBinarySubstrings(self, s):
        """
        :type s: str
        :rtype: int
        例如 s = 00111011，可以得到这样的 counts 数组：2,3,1,2
        它们能组成的满足条件的子串数目为 min{u,v}
        """
        count = [1]
        j = 0
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                count[j] += 1
            else:
                count.append(1)
                j += 1
        res = 0
        for k in range(1, len(count)):
            res += min(count[k], count[k - 1])
        return res
```



### **让字符串成为回文串的最少插入次数**

给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。

请你返回让 s 成为回文串的 最少操作次数 。

```python
class Solution(object):
    def minInsertions(self, s):
        """
        :type s: str
        :rtype: int
        转成其他问题求解
        求最长回文子串的长度，字符串总长度减去最长回文子串长度就是答案

        dp(i, j) 表示[i, j]位置范围内的最长回文子串的长度

        s[i] == s[j]:
            dp(i, j) = 2 + dp[i+1, j-1]
        s[i] != s[j]:
            dp(i, j) = max(dp(i+1, j), dp(i, j-1))
        """
        n = len(s)

        dp = [[1 for _ in range(n)] for _ in range(n)]
        for i in range(n-2, -1, -1):
            for j in range(i+1, n):
                if s[i] == s[j]:
                    dp[i][j] = 2 + dp[i+1][j-1] if j - i >= 2 else 2
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]) if j - i >= 2 else 1
        return n - dp[0][n-1]

```



### **交换字符串中的两个字符一次或者什么都不做，返回最长的单字符重复子串的长度**

如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。

给你一个字符串 text，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。

```python
class Solution(object):
    def maxRepOpt1(self, text):
        """
        :type text: str
        :rtype: int
        1.  统计当前字母左侧有多少连续字母 右侧有多少连续字母，包含字母本身
        2.  当前字母左右两侧字母不相同，最大连续长度只能来自某一侧且需要判断是否还有可交换元素存在
        3.  当前字母左右两侧字母相同，最大连续长度由两侧序列共同组成，此时同样需要判断是否还有可交换元素存在, 对于“aaaaa”同样适用
        """
        if len(text) == 1:
            return 1
        if len(text) == 2:
            if text[0] == text[1]:
                return 2
            else:
                return 1
        left = [1] * len(text)
        right = [1] * len(text)
        
        for i in range(1, len(text)):
            if text[i] == text[i - 1]:
                left[i] = 1 + left[i - 1]
        for i in range(len(text) - 2, -1, -1):
            if text[i] == text[i + 1]:
                right[i] = 1 + right[i + 1]
        
        counter = collections.Counter(text)
        res = 1
        for i in range(1, len(text) - 1):
            if text[i - 1] != text[i + 1]:
                if counter[text[i - 1]] > left[i-1]:
                    res = max(res, left[i - 1] + 1)
                if counter[text[i + 1]] > right[i + 1]:
                    res = max(res, right[i + 1] + 1)
            else:
                if counter[text[i + 1]] > (left[i-1] + right[i + 1]):
                    res = max(res, left[i - 1] + 1 + right[i + 1])
                elif counter[text[i + 1]] == (left[i - 1] + right[i + 1]):
                    res = max(res, left[i - 1] + right[i + 1])
        return res
```



###  **字符串压缩**

```python
class Solution:
    def compressString(self, S: str) -> str:
        if not S:
            return ""
        ch = S[0]
        ans = ''
        cnt = 0
        for c in S:
            if c == ch:
                cnt += 1 
            else:
                ans += ch + str(cnt)
                ch = c 
                cnt = 1
        ans += ch + str(cnt)
        return ans if len(ans) < len(S) else S
```



### **字符串中回文子串的个数**

```python
class Solution(object):
    def countSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        令dp[i][j]表示子串s[i, j]是否是回文串
        1. i==j, 单个字符肯定是回文串
        2. s[i] == s[j] 并且 dp[i+1][j-1]是回文串，则dp[i][j]也是回文串
        3. 其他情形都不是回文串

        1，2合并
        j从0到n, i从0到j
        """
        res = 0
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        for j in range(n):
            for i in range(j + 1):
                if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):
                    dp[i][j] = 1
                    res += 1
        return res
```



### **最长公共子序列 可以不连续**

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

```python
class Solution(object):
    def longestCommonSubsequence(self, text1, text2):
        """
        :type text1: str
        :type text2: str
        :rtype: int
        dp[i][j] 的含义是：对于 s1[1..i] 和 s2[1..j]，它们的 LCS 长度是 dp[i][j]
        """
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = 1 + dp[i - 1][j - 1]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[-1][-1]
```



### **编辑距离：替换插入删除操作的最少操作数后使两字符串相同**

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：插入一个字符 删除一个字符 替换一个字符

```python
class Solution(object):
    def minDistance(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int

        简化为三种操作：
        在单词 A 中插入一个字符；
        在单词 B 中插入一个字符；
        修改单词 A 的一个字符。

        D[i][j] 表示 A 的前 i 个字母和 B 的前 j 个字母之间的编辑距离。

        若 A 和 B 的最后一个字母相同：
            D[i][j] = min(D[i][j−1]+1,D[i−1][j]+1,D[i−1][j−1])
        若 A 和 B 的最后一个字母不同：
            D[i][j]=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1])
        """
        n = len(word1)
        m = len(word2)

        D = [[0] * (m + 1) for _ in range(n + 1)]
        for i in range(n + 1):
            D[i][0] = i 

        for j in range(m + 1):
            D[0][j] = j  

        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if word1[i - 1] == word2[j - 1]:
                    D[i][j] = min(D[i][j - 1] + 1, D[i - 1][j] + 1, D[i - 1][j - 1])
                else:
                    D[i][j] = 1 + min(D[i][j - 1], D[i - 1][j], D[i - 1][j - 1])
        return D[n][m]  
```





### **Excel表列名称**

1 - A, 26 - Z, 27 - AA,  28- AB

```
class Solution(object):
    def convertToTitle(self, n):
        """
        :type n: int
        :rtype: str
        十进制转26进制
        26 转成 字母是z,26进制是10，需要从 商 借一个给余数
        """
        res = ""
        while n:
            n, y = divmod(n, 26) 
            if y == 0:
                n -= 1
                y = 26
            res = chr(y + 64) + res
        return res
```



### **Excel表列序号**

A -> 1 B -> 2 C -> 3 ... Z -> 26  AA -> 27  AB -> 28

```python
class Solution(object):
    def titleToNumber(self, s):
        """
        :type s: str
        :rtype: int
        和平常的2进制转10进制的过程一模一样，只是2换成了26而已。
        """
        if not s:
            return 0
        n = len(s)
        res = 0 
        for i in range(n):
            res += 26 ** (n-i-1) * (ord(s[i]) - 64)
        return res
```

 







## **数组**

### **两数之和**

给定一个未排序的整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

```python
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        n = len(nums)
        for x in range(n):
            a = target - nums[x]
            if a in nums:
                y = nums.index(a)
                if x == y:
                    continue
                else:
                    return x, y
                    break
            else:
                continue
```





### **三数之和**

```python
class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        if not nums or len(nums) < 3:
            return []
        nums.sort()
        result = []
        for start in range(0, len(nums) - 2):
            if nums[start] > 0:
                break
            if start > 0 and nums[start] == nums[start-1]:
                continue
            target = -nums[start]
            i, j = start + 1, len(nums) - 1
            while i < j:
                if nums[i] + nums[j] < target:
                    i += 1
                    while i < j and  nums[i - 1] == nums[i]:
                        i += 1
                elif nums[i] + nums[j] > target:
                    j -= 1
                    while i < j and  nums[j + 1] == nums[j]:
                        j -= 1
                else:
                    result.append([nums[start], nums[i], nums[j]])
                    i += 1
                    while i < len(nums) - 1 and nums[i - 1] == nums[i]:
                        i += 1
                    j -= 1
                    while j > 0 and nums[j + 1] == nums[j]:
                        j -= 1
        return result
```

 

### **岛屿的最大面积**

```python
class Solution(object):
    def dfs(self, grid, i, j):
        if 0<= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j]:
            grid[i][j] = 0
            return 1 + self.dfs(grid, i-1, j) + self.dfs(grid, i+1, j) + self.dfs(grid, i, j-1) + self.dfs(grid, i, j+1)
        return 0

    def maxAreaOfIsland(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        result = 0 
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                result = max(result, self.dfs(grid, i, j))
        return result
```



### **搜索旋转排序数组中的某个数字**

```python
# 搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。

class Solution:
    def search(self, arr: List[int], target: int) -> int:
        # 步骤1: 找分界点
        split = -1
        s, e = 0, len(arr) - 1
        n = len(arr)
        while s < e:
            if e - 1 >= 0 and arr[e - 1] > arr[e]:
                # 找到分界点了, 直接跳出循环
                split = e
                break
            m = (s + e) >> 1
            if arr[m] < arr[e]:
                e = m
            elif arr[m] > arr[e]:
                s = m + 1
            else:
                e -= 1

        # 步骤2: 左右有序区间的经典二分查找
        def bsearch(s, e):
            if s > e:
                return -1
            while s < e:
                m = (s+e) >> 1
                if arr[m] >= target:
                    # 即使等于target, 也要继续向左找, 看看有没有下标更小的
                    e = m
                else:
                    s = m+1
            # 最终收敛的值也不是target, 说明整个区间没有等于target的数字, 返回-1
            return -1 if arr[s] != target else s

        res = bsearch(0, split-1)
        if res != -1:
            return res
        return bsearch(split, len(arr)-1)


```



### **旋转数组的最小数字**

```python
class Solution(object):
    def minArray(self, numbers):
        """
        :type numbers: List[int]
        :rtype: int
        """
        i, j = 0, len(numbers) - 1
        while i < j:
            mid = (i + j) // 2
            if numbers[mid] > numbers[j]:
                i = mid + 1
            elif numbers[mid] < numbers[j]:
                j = mid
            else:
                j -= 1
        return numbers[i]
```









### **最长连续递增序列**

给定一个未经排序的整数数组，找到最长且**连续**的的递增序列，并返回该序列的长度。

```python
class Solution(object):
    def findLengthOfLCIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        if len(nums) < 2:
            return len(nums)
        result = 1
        i, j = 0, 0
        while j < len(nums):
            while j+1 < len(nums) and nums[j+1] > nums[j]:
                j += 1
            result = max(result, j - i + 1)
            j += 1
            i = j
        return result
```



### **最长上升子序列(子序列不需要连续)**

给定一个无序的整数数组，找到其中最长上升子序列的长度。

```python
class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度
        dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]
        result =max(dp[i]),其中0≤i<n
        """
        if not nums:
            return 0
        dp = []
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```









### **未排序整数数组的最长连续序列**

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？

```python
class Solution(object):
    def longestConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        a = set(nums)
        result = 0
        while a:
            num = a.pop()
            start, end = num, num
            while start - 1 in a:
                start -= 1
                a.remove(start)
            while end + 1 in a:
                end += 1
                a.remove(end)
            result = max(result, end - start + 1)
        return result
```



###  **数组中的第K个最大元素**

```python
from heapq import *
class Solution(object):
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        d = []
        for num in nums:
            if len(d) < k:
                heappush(d, num)
            elif num > d[0]:
                heappop(d)
                heappush(d, num)
        return heappop(d)
```



### **全排列（没有重复数字的数组）**

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrack(nums, tmp):
            if not nums:
                res.append(tmp)
                return 
            for i in range(len(nums)):
                backtrack(nums[:i] + nums[i+1:], tmp + [nums[i]])
        backtrack(nums, [])
        return res
```



### **全排列（有重复数字的数组）**

```python
class Solution(object):
    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        通过排序,来减少重复数组进入res
        """
        nums.sort()
        res = []
        visited = set()
        def backtrack(nums, tmp):
            if len(nums) == len(tmp):
                res.append(tmp)
                return 
            for i in range(len(nums)):
                if i in visited or (i > 0 and i - 1 not in visited and nums[i - 1] == nums[i]):
                    continue
                visited.add(i)
                backtrack(nums, tmp + [nums[i]])
                visited.remove(i)
        backtrack(nums, [])
        return res
```



### **返回 1 ... n 中所有可能的 k 个数的组合**

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

```python
class Solution(object):
    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        回溯+剪枝
        """
        result = []
        def back(candidates, cur):
            if len(cur) == k:
                result.append(cur[:])
                return 
            for i in range(len(candidates)):
                if len(cur) > 0 and candidates[i] < cur[-1]: #最重要是这一句实现剪枝，如果出现逆序就continue
                    continue
                cur.append(candidates[i])
                back(candidates[:i] + candidates[i + 1:], cur)
                cur.pop()
        
        nums = [i for i in range(1, n + 1)]
        back(nums, [])
        return result
```





### **第k个排列**

举例来说明。

n = 4， 参与排列的数字「1， 2， 3， 4」

列出所有的排列

1 + (permutations of 2, 3, 4)

2 + (permutations of 1, 3, 4)

3 + (permutations of 1, 2, 4)

4 + (permutations of 1, 2, 3)

n个数字的排列数为n!,那么3个数的排列数为6。假如k=14，那么第14个排列落在

3 + (permutations of 1, 2, 4)

令k=14-1(减去1是因为程序中索引从0开始), k/(n-1)!= 13/(4-1)! = 2, 在数列「1， 2， 3， 4」中索引为2的数字为3，所以第一个数字为3。

那么问题进一步缩小为「1， 2， 4」数字的排列，求第 k= k%(n-1)!=13%(4-1)=1 个排列：

1 + (permutations of 2, 4)

2 + (permutations of 1, 4)

4 + (permutations of 1, 2)

在这一步中，2个数字排列有2!， 总共有3*2!=6个，我们寻找第一个排列，那么落在

1 + (permutations of 2, 4)

此时 k/(n-2)! = 1/(4-2)! = 0, 即「1， 2， 4」中索引0的数字1。目前我们知道前面两个数字3，1。剩下的数字依次类推。

「2, 4」

k = k % (n-2)! = 1%(4-2)! = 1，第三个数字在「2， 4」中的索引为 k/(n-3)!= 1/(4-3)! = 1，所以第三个数字为4

「2」

k = k % (n-3)! = 1%(4-3)! = 0，第四个数字在「2」中的索引为 k/(n-4)!= 0/(4-4)! = 0，所以第四个数字为2

```python
class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        import math
        tokens = [str(i) for i in range(1, n+1)]
        res = ''
        k = k-1
        while n > 0:
            n -= 1
            a, k = divmod(k, math.factorial(n))
            res += tokens.pop(a)
        return res
```



### **朋友圈**

班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M i][j]= 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

```python
class Solution(object):
    def dfs(self, visit, i, M):
        for j in range(len(M)):
            if M[i][j] and j not in visit:
                visit.add(j)
                self.dfs(visit, j, M)
 
    def findCircleNum(self, M):
        """
        :type M: List[List[int]]
        :rtype: int
        """
        N = len(M)
        count = 0
        visit = set()
 
        for i in range(N):
            if i not in visit:
                count += 1
                visit.add(i)
                self.dfs(visit, i, M)
        return count
```



### **合并区间**

 [[1,3],[2,6],[8,10],[15,18]] ——》 [[1,6],[8,10],[15,18]]

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key = lambda x:x[0])
        merged = []
        for interval in intervals:
            if not merged or merged[-1][1]<interval[0]:
                merged.append(interval)
            else:
                merged[-1][1] = max(merged[-1][1],interval[1])
        return merged
```



### **接雨水**

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        if not height or len(height) == 0:
            return 0
        
        lr,rl =[0]*len(height),[0]*len(height)
        
        maxl = height[0]
        for i in range(0,len(height)):
            maxl = max(maxl,height[i])
            lr[i] = maxl
            
        maxr = height[-1]
        for i in range(len(height)-1,-1,-1):
            maxr = max(maxr,height[i])
            rl[i] = maxr
        
        res = [0] * len(height)
        
        for i in range(0,len(height)):
            res[i] = min(lr[i],rl[i]) - height[i]
            
        return sum(res)
```



### **前 K 个高频元素**

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        mapping = {}
        for num in nums:
            if num not in mapping:
                mapping[num] = 1
            else:
                mapping[num]+=1
        
        res = []
        for num in mapping:
            res.append([mapping[num],num])
        
        res.sort(key=lambda x:(x[0],x[1]),reverse=True)

        result = []
        for i in range(k):
            result.append(res[i][1])

        return result
```



### **将数组中的元素右移k个位置**

```python
class Solution(object):
    def reverse(self, nums, start, end):
        while start < end:
            temp = nums[start]
            nums[start] = nums[end]
            nums[end] = temp
            start += 1
            end -= 1


    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: None Do not return anything, modify nums in-place instead.
        我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 n-k 个元素
        """
        k %= len(nums)
        self.reverse(nums, 0, len(nums) - 1)
        self.reverse(nums, 0, k - 1)
        self.reverse(nums, k, len(nums) - 1)
```





### **移动零**

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if not nums or len(nums) == 0:
            return 
        i, j = 0, 0
        while i < len(nums) and j < len(nums):
            if nums[i] == 0:
                i += 1
            else:
                nums[j] = nums[i]
                i += 1
                j += 1
        while j < len(nums):
            nums[j] = 0
            j += 1
```



### **调整数组顺序使奇数位于偶数前面**

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

```python
class Solution:
    def exchange(self, nums: List[int]) -> List[int]:
        m,n = 0,len(nums)-1
        while m<n:
            if nums[m]%2 == 0:
                nums[m],nums[n] = nums[n],nums[m]
                n -= 1
            else:
                m += 1
        return nums

```



### **二分查找排序数组的指定值，返回下标**

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        i, j = 0, len(nums) - 1
        while i <= j:
            mid = (i + j) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                j = mid - 1 
            else:
                i = mid + 1
        return -1
```



### **二分查找数组中指定数字的出现次数**

```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        def findright(tar):
            i, j = 0, len(nums) - 1
            while i <= j:
                m = (i + j) // 2
                if nums[m] <= tar:
                    i = m + 1
                else:
                    j = m - 1
            return i 
        return findright(target) - findright(target - 1) 
```







### **从矩阵左上角到右下角的不同路径数量**

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1] * n for _ in range(m)]

        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[-1][-1]
```



### **0～n-1 的范围中找多个重复的数字**

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

方法1：先说hash表的做法

方法2：

(1)先判断a[i]==i;等于i就跳过去，i++即可
(2)若a[i]!=i,先比较a[i]和a[a[i]]是否相等，相等的话，就找到了，返回true就行。
(3)若a[i]和a[a[i]]不相等，两者交换位置

```python
class Solution(object):
    def findRepeatNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums or len(nums)==0:
            return False
        for i in range(0,len(nums)):
            if nums[i] == i:
                continue
            else:
                if nums[nums[i]] != nums[i]:
                    a = nums[nums[i]]
                    nums[nums[i]] = nums[i]
                    nums[i] = a
                else:
                    return nums[i]
        return -1
```



### **1-n的范围内找唯一的重复数字**

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

不能更改原数组（假设数组是只读的）；只能使用额外的 O(1) 的空间。

```
class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        按题目表达，设数组长度为n，则数组中元素∈[1,n−1]，且只有一个重复元素。一个直观的想法，设一个数字k∈[1,n−1]，统计数组中小于等于k的数字的个数count：
            若count<=k，说明重复数字一定在(k,n−1]的范围内。
            若count>k，说明重复数字一定在[0,k]的范围内。
        
        mid=(left+right)//2
        按照性质，统计数组中小于等于mid的元素个数count
        若 count<=mid，说明重复数字一定在(mid,right]的范围内。令left=mid+1
        若count>mid，说明重复数字一定在[left,mid]的范围内。令right=mid。
        """
        left = 1
        right = len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            count = 0
            for num in nums:
                if num <= mid:
                    count += 1
            if count <= mid:
                left = mid + 1
            else:
                right = mid
        return left
```









### **从左到右递增，从上到下递增的二维数组中的查找**

```python
class Solution(object):
    def findNumberIn2DArray(self, nums, target):
        if not nums or len(nums)==0 or not nums[0] or len(nums[0]) == 0:
            return False
        m,n = 0, len(nums[0])-1
        while m<len(nums) and n>=0:
            if nums[m][n] == target:
                return True
            elif nums[m][n] > target:
                n-=1
            else:
                m+=1
        return False
```



### **判断在一个矩阵中是否存在一条包含某字符串所有字符的路径**

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

```python
class Solution:
    def dfs(self,board,i,j,k,word):
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        if k == len(word)-1:
            return True
        tmp = board[i][j]
        board[i][j] = '/'
        res = self.dfs(board, i + 1, j, k + 1,word) or self.dfs(board, i - 1, j, k + 1,word) or self.dfs(board, i, j + 1, k + 1,word) or self.dfs(board, i, j - 1, k + 1, word)
        board[i][j] = tmp
        return res
 

    def exist(self, board: List[List[str]], word: str) -> bool:
        for i in range(len(board)):
            for j in range(len(board[0])):
                if self.dfs(board, i, j, 0, word):
                    return True
        return False
```



### **判断能够进入的行坐标和列坐标的数位之和不大于k的格子数量**

```python
class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        def digitsum(n):
            ans = 0
            while n:
                ans += n%10
                n //= 10
            return ans
            
        q= [(0,0)]
        s=set()
        while q:
            x, y = q.pop(0)
            if (x,y) not in s and 0 <= x < m and 0 <= y <n and digitsum(x) + digitsum(y) <= k:
                s.add((x,y))
                for nx,ny in [(x+1, y), (x, y + 1), (x - 1, y), (x , y - 1)]:
                    q.append((nx, ny))
        return len(s)
```



### **寻找两个正序数组的中位数**

```python
'''
num1: [a1,a2,a3,...an]
nums2: [b1,b2,b3,...bn]
合并后的数组： [nums1[:left1],nums2[:left2] | nums1[left1:], nums2[left2:]]
要保证左右两边的元素个数相同
如何找边界值，我们可以用二分法，我们先确定 num1 取 m1 个数的左半边，那么 num2 取 m2 = (m+n+1)/2 - m1 的左半边，找到合适的 m1，就用二分法找。
当 [ [a1],[b1,b2,b3] | [a2,..an],[b4,...bn] ]
我们只需要比较 b3 和 a2 的关系的大小，就可以知道这种分法是不是准确的！

例如：我们令：
nums1 = [-1,1,3,5,7,9]
nums2 =[2,4,6,8,10,12,14,16]
当 m1 = 4,m2 = 3 ,它的中位数就是median = (num1[m1] + num2[m2])/2
'''
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        n1 = len(nums1)
        n2 = len(nums2)
        if n1 > n2:
            return self.findMedianSortedArrays(nums2, nums1)
        k = (n1 + n2 + 1) // 2
        left = 0
        right = n1
        while left < right:
            m1 = left + (right - left) // 2
            m2 = k - m1
            if nums1[m1] < nums2[m2 - 1]:
                left = m1 + 1
            else:
                right = m1
        m1 = left 
        m2 = k - m1
        c1 = max(nums1[m1 - 1] if m1 > 0 else float("-inf"), nums2[m2 - 1] if m2 > 0 else float("-inf"))
        if (n1 + n2) % 2 == 1:
            return c1 
        c2 = min(nums1[m1] if m1 < n1 else float("inf"), nums2[m2] if m2 < n2 else float("inf"))
        return (c1 + c2)/2
```





### **顺时针打印矩阵**

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or len(matrix) == 0 or not matrix[0] or len(matrix[0]) == 0:
            return []
        left,right = 0,len(matrix[0])-1
        top,bottom = 0,len(matrix)-1

        result = []

        while True:
            for i in range(left,right+1):
                result.append(matrix[top][i])
            top+=1
            if top>bottom:
                break

            for i in range(top,bottom+1):
                result.append(matrix[i][right])
            right-=1
            if left>right:
                break

            for i in range(right,left-1,-1):
                result.append(matrix[bottom][i])
            bottom-=1
            if top>bottom:
                break
            
            for i in range(bottom,top-1,-1):
                result.append(matrix[i][left])
            left+=1
            if left>right:
                break
            
        return result
```



### **矩阵中的最长递增路径**

给定一个整数矩阵，找出最长递增路径的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

```python
class Solution(object):
    def longestIncreasingPath(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: int
        """
        if not matrix or not matrix[0]:
            return 0
        n, m = len(matrix), len(matrix[0])
        visited = {}
        def helper(i, j, num):
            if i < 0 or i >= n or j < 0 or j >= m or matrix[i][j] <= num:
                return 0
            if (i, j) in visited:
                return visited[(i, j)]
            else:
                tmp1 = helper(i + 1, j, matrix[i][j])
                tmp2 = helper(i - 1, j, matrix[i][j])
                tmp3 = helper(i, j + 1, matrix[i][j])
                tmp4 = helper(i, j - 1, matrix[i][j])
                dist = max(tmp1, tmp2, tmp3, tmp4) + 1
                visited[(i, j)] = dist
                return dist
        ans = []
        for i in range(n):
            for j in range(m):
                ans.append(helper(i, j, float('-inf')))
        return max(ans)
```



### **扑克牌中的顺子**

```python
# 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

class Solution:
    def isStraight(self, nums: List[int]) -> bool:
        nums.sort()

        numOfZero = 0
        for i in range(0,len(nums)):
            if nums[i] == 0:
                numOfZero+=1

        init = nums[numOfZero]
        distance = 0
        for i in range(numOfZero+1,len(nums)):
            if nums[i] == (init + 1):
                init = nums[i]
                continue
            elif nums[i] == init:
                return False
            else:
                distance += (nums[i]-init-1)
                init = nums[i]
        return True if distance<=numOfZero else False
```



### **课程表**

你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

```python
class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        def dfs(i, visited, adjacency):
            if visited[i] == 1:
                return False
            visited[i] = 1
            for j in adjacency[i]:
                if not dfs(j, visited, adjacency):
                    return False
            visited[i] = 0
            return True

        adjacency = [[] for _ in range(numCourses)]
        for cur, pre in prerequisites:
            adjacency[cur].append(pre)
        for i in range(numCourses):
            visited = [0] * numCourses
            if not dfs(i, visited, adjacency):
                return False
        return True
```



### **课程表 II**

现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。



```python
class Solution(object):
    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: List[int]
        用visit来记录顶点的访问情况
        同时为了满足能判断环这个条件，用额外的onCycle来记录从某个点开始递归时的路径
        采用回溯的思想，当一条递归线走完之后，将onCycle状态再恢复成False。
        """
        G = [[] for _ in range(numCourses)]
        for i, j in prerequisites:
            G[j].append(i)
        visit = [False] * numCourses
        onCycle = [False] * numCourses
        res = []
        def dfs(v):
            visit[v] = True
            onCycle[v] = True
            for w in G[v]:
                if not visit[w]:
                    if not dfs(w):
                            return False
                elif onCycle[w]:
                    return False
            onCycle[v] = False
            res.insert(0, v)
            return True
        for v in range(numCourses):
            if not visit[v]:
                if not dfs(v):
                    return []
        return res
```





### **连续子数组的最大和**

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

```python
class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums or len(nums) == 0:
            return 0
        res = 0
        result = -float('inf')
        for i in range(len(nums)):
            if res <= 0:
                res = nums[i]
            else:
                res += nums[i]
            result = max(result, res)
        return result
```





### **被围绕的区域, 类似围棋**

给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。

找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。

```python
class Solution(object):
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；
        最后我们遍历这个矩阵，对于每一个字母：
            如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；
            如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。
        """
        if not board:
            return 
        n, m = len(board), len(board[0])

        def dfs(x, y):
            if not 0 <= x < n or not 0 <= y < m or board[x][y] != 'O':
                return 
            board[x][y] = 'A'
            dfs(x+1, y)
            dfs(x-1, y)
            dfs(x, y - 1)
            dfs(x, y + 1)
        
        for i in range(n):
            dfs(i, 0)
            dfs(i, m - 1)

        for i in range(m):
            dfs(0, i)
            dfs(n - 1, i)

        for i in range(n):
            for j in range(m):
                if board[i][j] == "A":
                    board[i][j] = "O"
                elif board[i][j] == "O":
                    board[i][j] = "X"
```





### **在排序数组中查找元素的第一个和最后一个位置**

```python
class Solution(object):
    def findFirst(self, nums, target):
        i, j = 0, len(nums) - 1
        while i <= j:
            mid = (i + j) // 2
            if nums[mid] < target:
                i += 1
            elif nums[mid] > target:
                j -= 1
            elif (nums[mid] == target and mid == 0) or (nums[mid] == target and nums[mid] != nums[mid - 1]):
                return mid
            else:
                j -= 1
        return -1
    
    def findLast(self, nums, target):
        i, j = 0, len(nums) - 1
        while i <= j:
            mid = (i + j) // 2
            if nums[mid] < target:
                i += 1
            elif nums[mid] > target:
                j -= 1
            elif (nums[mid] == target and mid == len(nums) - 1) or (nums[mid] == target and nums[mid] != nums[mid + 1]):
                return mid
            else:
                i += 1
        return -1


    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        return [self.findFirst(nums, target), self.findLast(nums, target)]
```



### **克隆图**

```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

#深度优先遍历
class Solution(object):
    def __init__(self):
        self.visited = {}

    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if not node:
            return node
        if node in self.visited:
            return self.visited[node]
        
        clone_node = Node(node.val, [])
        self.visited[node] = clone_node

        if node.neighbors:
            clone_node.neighbors = [self.cloneGraph(n) for n in node.neighbors]

        return clone_node
   

#广度优先遍历
class Solution(object):
    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if not node:
            return node
        visited = {}
        queue = [node]
        visited[node] = Node(node.val, [])

        while queue:
            n = queue.pop(0)
            for neighbor in n.neighbors:
                if neighbor not in visited:
                    visited[neighbor] = Node(neighbor.val, [])
                    queue.append(neighbor)
                visited[n].neighbors.append(visited[neighbor])
        return visited[node]
```



### **判断数组中是否存在两数值的差小于某个数且下标差小于另一个数**

在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。如果存在则返回 true，不存在返回 false。

```python
class Solution(object):
    def containsNearbyAlmostDuplicate(self, nums, k, t):
        """
        :type nums: List[int]
        :type k: int
        :type t: int
        :rtype: bool
        我们将数据分到 M 个桶 中。
        每个数字nums[i] 都被我们分配到一个桶中
        分配的依据就是 nums[i] // (t + 1)
        这样相邻桶内的数字最多相差2 * t + 1
        不相邻的桶一定不满足相差小于等于t
        同一个桶内的数字最多相差t

        因此如果命中同一个桶内，那么直接返回True
        如果命中相邻桶，我们再判断一下是否满足 相差 <= t
        否则返回False
        """
        bucket = dict()
        if t < 0:
            return False 
        for i in range(len(nums)):
            nth = nums[i] // (t + 1)
            if nth in bucket:
                return True 
            if nth - 1 in bucket and abs(nums[i] - bucket[nth - 1]) <= t:
                return True
            if nth + 1 in bucket and abs(nums[i] - bucket[nth + 1]) <= t:
                return True
            bucket[nth] = nums[i]
            if i >= k:
                bucket.pop(nums[i - k] // (t + 1))
        return False
```



### **从两个数组里拼接最大数**

给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。

```python
'''
1. 主要是第一步的思路分析很重要，如果从两个数组中取数，假设总共要取k个数，我们从第一个数组中取i个数，则应从第二个数组中取出k-i个数, 那么从第一个数组中取出来的i个数一定是从数组中可以取出来组成最大的i个数(相对位置不变), 这也就转换成了一个简洁点的子问题：如何从一个数组中取出k个数，使得这k个数拼接起来最大。
2. 对于这样一个子问题，可以用单调递减栈来解决，当遇到一个新的数，如果这个数比栈顶元素还大，并且把栈顶元素弹出之后，后面的数+栈里面的数总数还能保证凑够k个数，这样就弹出栈顶元素。
3. 最后考虑所有合法的i, 然后获取得到两个子数组中可以得到的最大拼接数数组，进行合并，合并的时候可以直接借用python列表可以直接比较字典序的特性来进行元素添加；
'''
class Solution:
    # 从nums中选取m个数能构成的最大的数字(数的相对位置不变)
    def max_one(self, nums: List[int], m: int):
        n = len(nums)
        stack = []
        for i, num in enumerate(nums):
            while stack and n-i+len(stack) > m and num > stack[-1]:
                stack.pop()
            stack.append(num)
            if len(stack) > m:
                stack.pop()
        return stack

    def merge(self, arr1: List[int], arr2: List[int]):
        res = []
        while arr1 and arr2:
            if arr1 > arr2:
                res.append(arr1.pop(0))
            else:
                res.append(arr2.pop(0))
        res += arr1 + arr2
        return res

    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        ans = []
        for i in range(k+1):
            if i > len(nums1) or k-i > len(nums2):
                continue
            arr1 = self.max_one(nums1, i)
            arr2 = self.max_one(nums2, k-i)
            ans = max(ans, self.merge(arr1, arr2))
        return ans
```



### **数组中只出现一次的数字（其余出现两次）**

```python
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        res = 0
        for i in range(0, len(nums)):
            res ^= nums[i]
        return res 
```



### **数组中两个数字都只出现了一次，其余都出现两次，找这两个数字**

```python
class Solution(object):
    def singleNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        任何一个数字异或它自己都是0。根据所有数字异或后某位不为1的把整个数组分为两部分，然后在每个部分里面找。
        """
        judge = nums[0]
        for i in range(1, len(nums)):
            judge ^= nums[i]
        
        div = 1
        while div & judge == 0:
            div <<= 1
        
        res1, res2 = 0, 0
        for num in nums:
            if num & div == 0:
                res1 ^= num
            else:
                res2 ^= num
        return [res1, res2]
```



### **数组中只出现一次的数字（其余出现三次）**

```java
/**
使用 与运算 ，可获取二进制数字 num 的最右一位 n1 = num & 1
无符号右移 num >>> 1，可以获得num所有位的值 
将 counts 各元素对 3 求余，则结果为 “只出现一次的数字” 的各二进制位
利用 左移操作 和 或运算 ，可将 counts 数组中各二进位的值恢复到数字 res 上
***/

class Solution {
    public int singleNumber(int[] nums) {
        int[] counts = new int[32];
        for(int num: nums){
            for(int j = 0; j < 32; j++){
                counts[j] += num & 1;
                num >>>= 1;
            }
        }
        int res = 0, m = 3;
        for(int i=0;i<32;i++){
            res <<= 1;
            res |= counts[31 - i] % m;
        }
        return res;
    }
}
```



### **数组中两元素的最大乘积（元素值都大于1）**

给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。

```python
class Solution(object):
    def maxProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        1、使用两个变量，一个存放最大值（默认为nums[0]），一个存放次大值（默认为0）
        2、从下标为1处开始遍历nums数组，一次进行最大值和次大值的赋值。
        3、注意处理下特殊情况：最大值和次大值的数值相同
        """
        if len(nums) == 2:
            return (nums[0] - 1) * (nums[1] - 1)
        
        one, two = nums[0], 0
        for i in range(1, len(nums)):
            if nums[i] > one:
                two = one
                one = nums[i]
            elif nums[i] <= one:
                if nums[i] >= two:
                    two = nums[i]

        return (one - 1) * (two - 1)
```



### **给定坐标和新颜色，给连着的色块上色**

有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。

给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。

为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

```
# 733
class Solution(object):
    def floodFill(self, image, sr, sc, newColor):
        """
        :type image: List[List[int]]
        :type sr: int
        :type sc: int
        :type newColor: int
        :rtype: List[List[int]]
        dfs遍历
        """
        n, m = len(image), len(image[0])
        currColor = image[sr][sc]

        def dfs(x, y):
            if image[x][y] == currColor:
                image[x][y] = newColor
                for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                    if 0 <= mx < n  and 0 <= my < m and image[mx][my] == currColor:
                        dfs(mx, my)
        
        if currColor != newColor:
            dfs(sr, sc)
        return image



class Solution(object):
    def floodFill(self, image, sr, sc, newColor):
        """
        :type image: List[List[int]]
        :type sr: int
        :type sc: int
        :type newColor: int
        :rtype: List[List[int]]
        bfs
        """
        currColor = image[sr][sc]
        if currColor == newColor:
            return image
        
        n, m = len(image), len(image[0])
        queue = [[sr, sc]]
        image[sr][sc] = newColor

        while queue:
            x, y = queue.pop(0)
            for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1),(x, y + 1)]:
                if 0 <= mx < n and 0 <= my < m and image[mx][my] == currColor:
                    queue.append([mx, my])
                    image[mx][my] = newColor
        return image
```



### **数组中出现次数超过一半的数字**

```python
class Solution(object):
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        票数和： 由于众数出现的次数超过数组长度的一半；若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 >0 。
        票数正负抵消： 设数组 nums 中的众数为 x ，数组长度为 n 。若 nums 的前 a 个数字的 票数和 =0 ，则 数组后 (n-a) 个数字的 票数和一定仍 >0 （即后 (n-a) 个数字的 众数仍为 x ）。
        """
        votes = 0
        for num in nums:
            if votes == 0:
                x = num
            if num == x:
                votes += 1
            else:
                votes -= 1
        return x
```



### **数组元素表示可跳跃的步骤，判断是否能跳到数组最右端**

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

```python
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 x + nums[x] 更新 最远可以到达的位置。
        """
        n, rightMax = len(nums), 0 
        for i in range(n):
            if i <= rightMax:
                rightMax = max(rightMax, i + nums[i])
                if rightMax >= n - 1:
                    return True
        return False
```





### **找出该数组中满足其和 ≥ s 的长度最小的连续子数组**

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

```python
#209
class Solution(object):
    def minSubArrayLen(self, s, nums):
        """
        :type s: int
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        if n == 0:
            return 0
        ans = float('inf')
        start, end = 0, 0 
        sumVal = 0
        while end < n:
            sumVal += nums[end]
            while sumVal >= s:
                ans = min(ans, end - start + 1)
                sumVal -= nums[start]
                start += 1
            end += 1
        if ans == float('inf'):
            return 0
        else:
            return ans
```



### **不用临时变量交换数组中的两个数字**

```python
class Solution(object):
    def swapNumbers(self, numbers):
        """
        :type numbers: List[int]
        :rtype: List[int]
        """
        numbers[0] ^= numbers[1]
        numbers[1] ^= numbers[0]
        numbers[0] ^= numbers[1]
        return numbers
```



### **在先递增后递减的数组里面找目标值([山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/))**

```python
# """
# 1095
# This is MountainArray's API interface.
# You should not implement it, or speculate about its implementation
# """
#class MountainArray(object):
#    def get(self, index):
#        """
#        :type index: int
#        :rtype int
#        """
#
#    def length(self):
#        """
#        :rtype int
#        """

class Solution(object):
    def findInMountainArray(self, target, mountain_arr):
        """
        :type target: integer
        :type mountain_arr: MountainArray
        :rtype: integer

        第 1 步：先找到山顶元素 mountaintop 所在的索引。
        第 2 步：在前有序且升序数组中找 target 所在的索引，如果找到了，就返回，如果没有找到，就执行第 3 步；
        第 3 步：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引。
        """
        length = mountain_arr.length()
        mountaintop = self.findMountainTop(mountain_arr, 0, length - 1)
        res = self.findSorted(mountain_arr, 0, mountaintop, target)
        if res != -1:
            return res
        return self.findReversed(mountain_arr, mountaintop + 1, length - 1, target)

        
    def findMountainTop(self, mountain_arr, l, r):
        while l < r:
            mid = (l + r) // 2
            if mountain_arr.get(mid) < mountain_arr.get(mid + 1):
                l = mid + 1
            else:
                r = mid 
        return l 

    def findSorted(self, mountain_arr, l, r, target):
        while l < r:
            mid = (l + r) // 2
            if mountain_arr.get(mid) < target:
                l = mid + 1
            else:
                r = mid
        if mountain_arr.get(l) == target:
            return l 
        return -1 

    def findReversed(self, mountain_arr, l, r, target):
        while l < r:
            mid = (l + r) // 2
            if mountain_arr.get(mid) > target:
                l = mid + 1
            else:
                r = mid
        if mountain_arr.get(l) == target:
            return l 
        return -1
```



### **找到数组的所有递增子序列**

给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

输入: [4, 6, 7, 7]
输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]

```python
class Solution(object):
    def findSubsequences(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        深度优先搜索+哈希表

        1. 定义返回列表res保存所有递增子序列：
        2. 深度优先搜索（dfs），参数：nums，tmp保存当前递增子序列：

        如果当前递增子序列符合要求：res增加tmp
        定义字典保存状态，避免重复！
        inx, i循环nums的索引值对。
            如果当前值在以前已被遍历：
                跳出当前循环，开始下一次循环。
            如果i加入tmp可以形成递增子序列：
                i为键，1为值加入字典；
                递归：
                    nums = nums[inx+1:]；
                    tmp = tmp+[i]。
        3. 调用dfs：
            nums = nums
            tmp = []
        返回res
        """
        res = []
        def dfs(nums, tmp):
            if len(tmp) > 1:
                res.append(tmp)
            curPres = defaultdict(int)
            for inx, i in enumerate(nums):
                if curPres[i]:
                    continue
                if not tmp or i >= tmp[-1]:
                    curPres[i] = 1
                    dfs(nums[inx + 1:], tmp + [i])
        dfs(nums, [])
        return res
```





## **链表**

### **合并两个有序链表**

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def mergeTwoLists(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        if not l1:
            return l2
        if not l2:
            return l1
        dummy = ListNode(0)
        p = dummy
        while l1 and l2:
            if l1.val < l2.val:
                p.next = l1
                l1 = l1.next
                p = p.next
            else:
                p.next = l2
                l2 = l2.next
                p = p.next
        if l1:
            p.next = l1
        if l2:
            p.next = l2
        return dummy.next
```



### **反转链表**

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        pre = None
        cur = head
        while cur:
            nextNode = cur.next
            cur.next = pre
            pre = cur
            cur = nextNode
        return pre
```



### **反转从位置 m 到 n 的链表**

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        if not head:
            return
        dummy = ListNode(0)
        dummy.next = head
        p = dummy

        for _ in range(m):
            pre = p
            p = p.next
        
        back = p
        temp1 = None
        temp2 = None
        for _ in range(n - m + 1):
            temp1 = p.next
            p.next = temp2 
            temp2 = p 
            p = temp1
        pre.next = temp2
        back.next = temp1
        return dummy.next
```





### **两数相加(链表逆序的)**

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        node = dummy
        p, q = l1, l2
        carry = 0
        while p and q:
            val = p.val + q.val + carry
            if val >= 10:
                carry = 1
                val -= 10
            else:
                carry = 0
            node.next = ListNode(val)
            node = node.next
            p = p.next
            q = q.next
        while p:
            val = p.val + carry
            if val >= 10:
                carry = 1
                val -= 10
            else:
                carry = 0
            node.next = ListNode(val)
            node = node.next
            p = p.next 
        while q:
            val = q.val + carry
            if val >= 10:
                carry = 1
                val -= 10
            else:
                carry = 0
            node.next = ListNode(val)
            node = node.next
            q = q.next

        if carry:
            node.next = ListNode(1)
        return dummy.next
```



### **两数相加 II（链表正序）**

```
输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 8 -> 0 -> 7
```

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        res1 = 0
        res2 = 0
        while l1:
            res1 = res1 * 10 + l1.val
            l1 = l1.next
        while l2:
            res2 = res2 * 10 + l2.val 
            l2 = l2.next
        res = res1 + res2
        resStr = str(res)
        dummy = ListNode(0)
        p =dummy
        i = 0
        while i < len(resStr):
            p.next = ListNode(int(resStr[i]))
            p = p.next
            i += 1
        return dummy.next
```





### **排序链表**

利用递归排序的思想做，先把链表分割成单独的一个节点，最后合并链表

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def merge(self, left, right):
        dummy = ListNode(0)
        p = dummy
        l = left 
        r = right
        while l and r:
            if l.val < r.val:
                p.next = l 
                l = l.next
                p = p.next
            else:
                p.next = r 
                r = r.next
                p = p.next
        if l:
            p.next = l 
        if r:
            p.next = r 
        return dummy.next


    def sortList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head or not head.next:
            return head
        slow = head
        fast = head 
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        mid = slow.next
        slow.next = None
        left = self.sortList(head)
        right = self.sortList(mid)
        return self.merge(left, right)
```



### **返回环形链表的第一个入环节点**

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                fast = head
                while fast != slow:
                    fast = fast.next
                    slow = slow.next
                return fast
        return
```



### **相交链表**， **两个链表的第一个公共节点**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p, q = headA, headB
        len1, len2 = 0, 0
        while p:
            len1 += 1
            p = p.next
        while q:
            len2 += 1
            q = q.next
         
        p, q = headA, headB
        if len1 > len2:
            for i in range(len1 - len2):
                p = p.next
        if len2 > len1:
            for i in range(len2 - len1):
                q = q.next
        while p != q:
            p = p.next
            q = q.next
        return p 
```



### **合并K个排序链表**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
 
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
 
        if not l1 and not l2:
            return 
        if not l1:
            return l2
        if not l2:
            return l1
 
        p,q = l1,l2
        d = dummy
        while p and q:
            if p.val<q.val:
                d.next = p
                p = p.next
                d = d.next
            else:
                d.next=q
                q=q.next
                d=d.next
        if p:
            d.next = p
        if q:
            d.next= q
        return dummy.next
 
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists or len(lists) ==0:
            return
        if len(lists) == 1:
            return lists[0]
        node = self.mergeTwoLists(lists[0], lists[1])
        for i in range(2, len(lists)):
            node = self.mergeTwoLists(node, lists[i])
        return node
```



### **链表的中间结点**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow,fast = head,head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```



### **链表中倒数第k个节点**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        fast,small = head,head
        while k>1:
            fast = fast.next
            k-=1
        while fast.next:
            fast= fast.next
            small = small.next
        return small
```



### **删除链表的倒数第N个节点**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head
        length = 0
        first = head 
        while first:
            length += 1
            first = first.next
        length -= n 
        first = dummy
        while length > 0:
            length -= 1
            first = first.next
        first.next = first.next.next
        return dummy.next
```





### **删除链表中的某个给定节点**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, head: ListNode, val: int) -> ListNode:
        if not head:
            return 
        dummy = ListNode(-1)
        dummy.next = head
        pre,cur = dummy, head
        while cur:
            if cur.val == val:
                pre.next = cur.next
                return dummy.next
            pre, cur = pre.next, cur.next
        return head
```



### **删除链表中的重复节点（留一个）**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head:
            return
        cur = head  
        while cur:
            while cur.next and cur.next.val == cur.val:
                cur.next = cur.next.next
            cur = cur.next
        return head
```





### **删除链表中的所有重复节点（一个都不留）**

```python
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def deleteDuplication(self, pHead):
        # write code here
        if not pHead oor not pHead.next:
            return pHead
        dummy = ListNode(-1)
        dummy.next = pHead
        pre,cur = dummy,pHead
        while cur and cur.next:
            nextNode = cur.next
            if cur.val == nextNode.val:
                while nextNode and cur.val == nextNode.val:
                    nextNode = nextNode.next
                pre.next = nextNode
                cur = nextNode
            else:
                pre = cur
                cur = nextNode
        return dummy.next        
```



### **K 个一组翻转链表**

```python
class Solution:
    # 翻转一个子链表，并且返回新的头与尾
    def reverse(self, head: ListNode, tail: ListNode):
        prev = tail.next
        p = head
        while prev != tail:
            nex = p.next
            p.next = prev
            prev = p
            p = nex
        return tail, head

    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head
        pre = dummy

        while head:
            tail = pre
            # 查看剩余部分长度是否大于等于 k
            for i in range(k):
                tail = tail.next
                if not tail:
                    return dummy.next
            nex = tail.next
            head, tail = self.reverse(head, tail)
            # 把子链表重新接回原链表
            pre.next = head
            tail.next = nex
            pre = tail
            head = tail.next
        
        return dummy.next
```





### **两两交换链表中的节点**

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        pre = ListNode(0)
        pre.next = head 
        temp = pre 
        while temp.next and temp.next.next:
            start = temp.next
            end = temp.next.next
            temp.next = end
            start.next = end.next
            end.next = start
            temp = start
        return pre.next 
```







## **树**



### **前序遍历**

递归死记

循环，前序先把右节点加入栈，再把左节点加入栈

```python
def helper(self, root, res):
        if not root:
            return 
        res.append(root.val)
        self.helper(root.left, res)
        self.helper(root.right, res)
 
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        if not root:
            return res
        self.helper(root, res)
        return res 
     
    def preorderTraversal2(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        if not root:
            return res 
        stack = [root]
        while stack:
            cur = stack.pop()
            res.append(cur.val)
            if cur.right:
                stack.append(cur.right)
            if cur.left:
                stack.append(cur.left)
        return res
```



### **中序遍历**

开始先把所有的左节点加入栈，弹出最顶层的左节点；接着访问它的右节点

```python
class Solution(object):
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        if not root:
            return res
        cur = root
        stack = []
        while cur oor stack:
            while cur:
                stack.append(cur)
                cur = cur.left 
            cur = stack.pop()
            res.append(cur.val)
            cur = cur.right
        return res 
```



### **后序遍历**

结果数组加入的时候从头加，栈里面先存入头节点；每次栈中弹出最后一个元素，从头加入结果数组；如果有左右节点记得加入栈！

```
class Solution(object):
    def helper(self, res, root):
        if not root:
            return
        self.helper(res, root.left)
        self.helper(res, root.right)
        res.append(root.val)
 
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        if not root:
            return res
        self.helper(res, root)
        return res
 
    def postorderTraversal2(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        if not root:
            return res
        stack = [root]
        while stack:
            cur = stack.pop()
            res.insert(0, cur.val)
            if cur.left:
                stack.append(cur.left)
            if cur.right:
                stack.append(cur.right)
        return res
```





### **二叉树的最近公共祖先**

先分别找到从根节点到目标节点的路径，依次对比两条路径，最后一个相同的节点就是最近公共祖先节点

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def getPath(self,root,tar,path):
        if not root:
            return False
        path.append(root)
        if root == tar:
            return True
        ret = self.getPath(root.left,tar,path) or self.getPath(root.right,tar,path)

        if ret:
            return True
        path.pop()
        return False

    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        pres,qres = [],[]
        self.getPath(root,p,pres)
        self.getPath(root,q,qres)

        minLen = min(len(pres),len(qres))

        i=0
        while i<minLen:
            if pres[i] == qres[i]:
                i+=1
            else:
                break
        return pres[i-1]
    
    
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if not root or root == p or root == q: 
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left: return right
        if not right: return left
        return root
```



### **二叉树的锯齿形层次遍历**

```python
# 103 Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        result = []
        layer = 0
        while queue:
            size = len(queue)
            curLayer = []
            layer += 1
            for k in range(size):
                node = queue.pop(0)
                curLayer.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            if layer % 2 == 0:
                curLayer.reverse()
            result.append(curLayer)
        return result
```



### 二叉树每个结点增加next 属性，给二叉树同一层的元素之间用next相连（用层序遍历，队列）

```python
#117
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        
        def bfs(oneLayer):
            nextLayer = []
            for i in oneLayer:
                if i.left:
                    nextLayer.append(i.left)
                if i.right:
                    nextLayer.append(i.right)

            if len(nextLayer) > 1:
                for j in range(0, len(nextLayer) - 1):
                    nextLayer[j].next = nextLayer[j + 1]
            
            if nextLayer:
                bfs(nextLayer)
        
        bfs([root])
        return root
```



### **二叉树的右视图**

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        # BFS
        if not root:
            return []
        result = []
        queue = [root]

        while queue:
            result.append(queue[-1].val)
            size = len(queue)
            for i in range(0,size):
                node = queue.pop(0)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return result
```



### **二叉树的最小深度**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def minDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        stack = [root]
        depth = 1
        while stack:
            length = len(stack)
            while length > 0:
                a = stack.pop(0)
                if not a.left and not a.right:
                    return depth
                if a.left:
                    stack.append(a.left)
                if a.right:
                    stack.append(a.right)
                length -= 1
            depth += 1
```



### **二叉树的最大深度（二叉树的深度）**

```python
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        leftDepth = self.maxDepth(root.left)
        rightDepth = self.maxDepth(root.right)
        return max(leftDepth, rightDepth) + 1
```



### **判断是否是平衡二叉树**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def getDepth(self, root):
        if not root:
            return 0
        leftDepth = self.getDepth(root.left)
        rightDepth = self.getDepth(root.right)
        return max(leftDepth, rightDepth) + 1


    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        return abs(self.getDepth(root.left) - self.getDepth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)
```



### **判断是否是二叉搜索树**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        递归
        判断子树中所有节点的值是否都在 (l,r)的范围内
        """
        def helper(node, lower = float('-inf'), upper = float('inf')):
            if not node:
                return True
            val = node.val
            if val <= lower or val >= upper:
                return False
            if not helper(node.right, val, upper):
                return False
            if not helper(node.left, lower, val):
                return False
            return True
        return helper(root)
```





### **二叉树的直径**

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def maxDepth(self,root,d):
        if not root:
            return 0
        left=self.maxDepth(root.left,d)
        right = self.maxDepth(root.right,d)
        d[0] = max(d[0],left+right)
        return max(left,right)+1

    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        d =[0]
        self.maxDepth(root,d)
        return d[0]
```



### **从根节点到叶子节点路径总和等于给定目标和的路径**

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def helper(self, result, path, root, sum):
        if not root:
            return
        sum -= root.val
        path.append(root.val)
        if not root.left and not root.right and sum == 0:
            result.append(path[:])
        self.helper(result, path, root.left, sum )
        self.helper(result, path, root.right, sum)
        path.pop()

    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
        result = []
        self.helper(result, [], root, sum)
        return result
```





### **判断是否是一个完全二叉树**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isCompleteTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        isFinish = False
        queue = [root]
        result = []
        while queue:
            size = len(queue)
            for i in range(size):
                node = queue.pop(0)
                if not node and not isFinish:
                    isFinish = True
                elif not node and isFinish:
                    continue
                elif node and isFinish:
                    return False
                else:
                    queue.append(node.left)
                    queue.append(node.right)
        return True
```



### **判断镜像对称**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isMirror(self,t1,t2):
        if not t1 and not t2:
            return True
        if not t1 or not t2:
            return False
        return t1.val == t2.val and self.isMirror(t1.right,t2.left) and self.isMirror(t1.left,t2.right)

    def isSymmetric(self, root: TreeNode) -> bool:
        return self.isMirror(root,root)
```



### **剪枝 返回移除了所有不包含 1 的子树的原二叉树**

给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。返回移除了所有不包含 1 的子树的原二叉树。

后序遍历，判断当前节点值是否为0，左右子节点，是否为空，均是则减掉

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def pruneTree(self, root: TreeNode) -> TreeNode:
        if root.left:
            root.left = self.pruneTree(root.left)
        if root.right:
            root.right = self.pruneTree(root.right)
        if not root.left and not root.right and root.val == 0:
            return 
        return root
```



### **判断一棵树是不是另一棵树的子树**

给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSameTree(self, s, t):
        if not s and not t:
            return True
        if not s or not t:
            return False
        return s.val == t.val and self.isSameTree(s.left, t.left) and self.isSameTree(s.right, t.right)

    def isSubtree(self, s, t):
        """
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """
        if not s and not t:
            return True
        if not s or not t:
            return False
        return self.isSameTree(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
```







### **判断数组是不是某二叉搜索树的后序遍历结果**

```python
class Solution(object):
    def verify(self, sequence, first, last):
        if last - first <= 1:
            return True
        rootVal = sequence[last]
        curIndex = first
        while curIndex < last and sequence[curIndex] < rootVal:
            curIndex += 1
        for i in range(curIndex, last):
            if sequence[i] < rootVal:
                return False
        return self.verify(sequence, first, curIndex - 1) and self.verify(sequence, curIndex, last - 1)

    def verifyPostorder(self, postorder):
        """
        :type postorder: List[int]
        :rtype: bool
        """
        if not postorder or len(postorder) == 0:
            return True
        return self.verify(postorder, 0, len(postorder) - 1)
```



### **根据前序preorder和中序遍历inorder的数组重建二叉树**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        if not preorder or not inorder or len(preorder) == 0 or len(inorder)==0:
             return
          
        mapping = {}
        for index in range(0,len(inorder)):
            mapping[inorder[index]] = index
  
        rootval = preorder[0]
        root = TreeNode(rootval)
        rootindex = mapping[rootval]
  
        root.left = self.buildTree(preorder[1:1+rootindex],inorder[0:rootindex])
        root.right = self.buildTree(preorder[1+rootindex:],inorder[rootindex+1:])
  
        return root
```



### **找出中序遍历顺序的下一个结点**

（1）如果节点有右子树，下一个节点就是它的右子树的最左子节点
（2）如果当前节点没有右子树，沿着父节点的指针一直向上遍历，直到找到一个节点A。直到之前父节点的指针是节点A的左节点。

```python
# -*- coding:utf-8 -*-
# class TreeLinkNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#         self.next = None
class Solution:
    def GetNext(self, pNode):
        # write code here
        if not pNode:
            return pNode
        if pNode.right:
            left1=pNode.right
            while left1.left:
                   left1=left1.left
            return left1
        p=pNode
        while pNode.next:
            tmp=pNode.next
            if tmp.left==pNode:
                return tmp
            pNode=tmp
        return
```



### **二叉搜索树的第k大节点**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def helper(self, nums, root):
        if not root:
            return
        self.helper(nums, root.left)
        nums.append(root.val)
        self.helper(nums, root.right)

    def kthLargest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        if not root:
            return
        nums = []
        self.helper(nums, root)
        return nums[-k]
```



### **二叉搜索树转换为双向链表**

```python
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def helper(self, node, result):
        if not node:
            return []
        self.helper(node.left, result)
        result.append(node)
        self.helper(node.right, result)
         
    def NodeList(self,node):
        if not node:
            return []
        result = []
        self.helper(node, result)
        return result 
     
    def Convert(self, pRootOfTree):
        # write code here
        nodes = self.NodeList(pRootOfTree)
        if len(nodes)==0:
            return None
        if len(nodes) == 1:
            return pRootOfTree
        nodes[0].left = None
        nodes[0].right = nodes[1]
        nodes[-1].left = nodes[-2]
        nodes[-1].right = None
         
        for i in range(1,len(nodes)-1):
            nodes[i].left = nodes[i-1]
            nodes[i].right = nodes[i+1]
        return nodes[0]
```



### **有序链表转换二叉搜索树**

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def getMid(self, left, right):
        fast = slow = left 
        while fast != right and fast.next != right:
            fast = fast.next.next
            slow = slow.next
        return slow

    def buildTree(self, left, right):
        if left == right:
            return 
        mid = self.getMid(left, right)
        root = TreeNode(mid.val)
        root.left = self.buildTree(left, mid)
        root.right = self.buildTree(mid.next, right)
        return root 


    def sortedListToBST(self, head):
        """
        :type head: ListNode
        :rtype: TreeNode
        """
        return self.buildTree(head, None)
```







### **恢复乱序的二叉搜索树**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def recoverTree(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        用中序遍历找到两个乱序的节点
        """
        self.firstNode, self.secondNode = None, None
        self.preNode = TreeNode(float('-inf'))

        def inOrder(root):
            if not root:
                return 
            inOrder(root.left)
            if not self.firstNode and self.preNode.val >= root.val:
                self.firstNode = self.preNode
            if self.firstNode and self.preNode.val >= root.val:
                self.secondNode = root
            self.preNode = root
            inOrder(root.right)
        inOrder(root)
        self.firstNode.val, self.secondNode.val = self.secondNode.val, self.firstNode.val



class Solution(object):
    def recoverTree(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        用中序遍历找到两个乱序的节点
        """
        firstNode, secondNode = None, None
        preNode = TreeNode(float('-inf'))

        stack = []
        p = root 
        while p or stack:
            while p:
                stack.append(p)
                p = p.left
            p = stack.pop()
            if not firstNode and preNode.val > p.val:
                firstNode = preNode
            if firstNode and preNode.val > p.val:
                secondNode = p
            preNode = p 
            p = p.right
        firstNode.val, secondNode.val = secondNode.val, firstNode.val
        
```



### **序列化和反序列化二叉搜索树**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
# 用前序遍历序列化二叉树,反序列的时候重新构建树

class Codec:
    def preOrder(self, root, res):
        if not root:
            return 
        res.append(root.val)
        self.preOrder(root.left, res)
        self.preOrder(root.right, res)


    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        result = []
        self.preOrder(root, result)
        return ' '.join([str(i) for i in result])
        

    def buildTree(self, data):
        if not data:
            return
        root = TreeNode(data[0])
        left = [i for i in data if i < data[0]]
        right = [i for i in data if i > data[0]]
        root.left = self.buildTree(left)
        root.right = self.buildTree(right)
        return root 


    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        data = data.split()
        data = [int(i) for i in data]
        return self.buildTree(data)
```





### **二叉树中的最大路径和**

路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def __init__(self):
        self.maxSum = float("-inf")
    
    def maxGain(self, node):
        if not node:
            return 0
        leftGain = max(self.maxGain(node.left), 0)
        rightGain = max(self.maxGain(node.right), 0)
        priceNewPath = node.val + leftGain + rightGain
        self.maxSum = max(self.maxSum, priceNewPath)
        return node.val + max(leftGain, rightGain)

    def maxPathSum(self, root: TreeNode) -> int:
        self.maxGain(root)
        return self.maxSum
```



### **从根节点到叶子节点每条路径看作一个数，求这些数的和**

给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。计算从根到叶子节点生成的所有数字之和。

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def sumNumbers(self, root):
        """
        :type root: TreeNode
        :rtype: int
        深度优先搜索
        """
        if not root:
            return 0
        self.sum = 0
        def dfs(node, curSum):
            if node.left:
                dfs(node.left, curSum + str(node.left.val))
            if node.right:
                dfs(node.right, curSum + str(node.right.val))
            if not node.left and not node.right:
                self.sum += int(curSum)
        dfs(root, str(root.val))
        return self.sum 
```



### **完全二叉树的节点个数**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        完全二叉树的节点个数等于 2^{h} - 1
        时间复杂度： O(log(n)^2) = O(log(n))
        """
        if not root:
            return 0
        left_height = 0
        left_node = root
        right_height = 0
        right_node = root 
        while left_node:
            left_node = left_node.left
            left_height += 1
        while right_node:
            right_node = right_node.right
            right_height += 1
        if left_height == right_height:
            return pow(2, left_height) - 1
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
```



### **分裂二叉树的最大乘积**

给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。

由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def maxProduct(self, root):
        """
        :type root: TreeNode
        :rtype: int
        用递归算法，自底而上计算每个节点作为根节点的子树的和cost，那么以该节点分开的话，两部分的分别为 cost，总和-cost
        遍历每个节点的cost，计算cost*（all_cost-cost）的最大值
        """
        cost_list = dict()
        cur_node = root
        def dfs(curnode, cost_list):
            if not curnode:
                return 0
            left_cost = dfs(curnode.left, cost_list)
            right_cost = dfs(curnode.right, cost_list)

            cur_cost = left_cost + curnode.val + right_cost
            cost_list[curnode] = cur_cost

            return cur_cost
        
        all_cost = dfs(cur_node, cost_list)
        max_cost = 0
        for key, value in cost_list.items():
            if value * (all_cost - value) > max_cost:
                max_cost = value * (all_cost - value)
        return max_cost % (10**9 + 7)
```



### **实现前缀树**

```python
class TrieNode:
    def __init__(self):
        self.children = collections.defaultdict(TrieNode)
        self.is_word = False

class Trie(object):
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TrieNode()


    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: None
        """
        curr = self.root
        for c in word:
            curr = curr.children[c]
        curr.is_word = True


    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        current = self.root 
        for letter in word:
            current = current.children.get(letter)
            if not current:
                return False
        return current.is_word



    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """
        current = self.root
        for c in prefix:
            current = current.children.get(c)
            if not current:
                return False
        return True
```



### **左叶子之和**

计算给定二叉树的所有左叶子之和。

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    # 判断是否是叶子节点
    def helper(self, root):
        if not root:
            return False
        if not root.left and not root.right:
            return True
        else:
            return False 

    # 前序遍历，在遍历过程中，发现叶子结点 and 是左树的，则加入到self.res中
    def dfs(self, root, flag):
        if not root:
            return 0
        if self.helper(root) and flag:
            self.res += root.val 
        self.dfs(root.left, True)
        self.dfs(root.right, False)

    
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        前序遍历判断
        """
        self.res = 0
        self.dfs(root, False)
        return self.res
```







## **动态规划**

### **只允许完成一笔交易的股票买卖**

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        if not prices or len(prices)<2:
            return 0
        min_price = prices[0]
        profit = 0
        for price in prices:
            min_price = min(min_price, price)
            profit = max(profit, price - min_price)
        return profit
```



### **多次交易的股票买卖（同时只能有一笔交易）**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        for i in range(1,len(prices)):
            if prices[i] > prices[i-1]:
                profit += (prices[i]-prices[i-1])

        return profit
```



### **最大正方形**

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

```python
class Solution(object):
    def maximalSquare(self, matrix):
        """
        :type matrix: List[List[str]]
        :rtype: int
        """
        if not matrix:
            return 0
        m, n = len(matrix), len(matrix[0])
        d = [[0] * n for _ in range(m)]
 
        res = 0
        for i in range(m):
            if matrix[i][0] == "1":
                d[i][0] = 1
                res = 1
         
        for j in range(n):
            if matrix[0][j] == "1":
                d[0][j] = 1
                res = 1
         
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][j] == "1":
                    if d[i-1][j] >= 1 and d[i][j-1] >= 1 and d[i-1][j-1] >= 1:
                        d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1]) + 1
                    else:
                        d[i][j] = 1
                    res = max(res, d[i][j])
        return res * res
```



### **具有最大和的连续子数组**

```python
class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 
        result= nums[0]
        cur = nums[0]
        for i in range(1,len(nums)):
            if cur < 0:
                cur = nums[i]
            else:
                cur += nums[i]
            result = max(result, cur)
        return result
```



### **三角形最小路径和**

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

```python
class Solution(object):
    def minimumTotal(self, triangle):
        """
        :type triangle: List[List[int]]
        :rtype: int
        """
        m = len(triangle)

        for i in range(1, m):
            for j in range(i+1):
                if j== 0:
                    triangle[i][j] += triangle[i-1][j]
                elif j == i:
                    triangle[i][j] += triangle[i-1][j-1]
                elif 0 < j < i:
                    triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j])
        return min(triangle[-1])
```



### **俄罗斯套娃信封问题**

给长宽，最多能有多少个信封能组成一组“俄罗斯套娃”信封

```python
class Solution(object):
    def maxEnvelopes(self, envelopes):
        """
        :type envelopes: List[List[int]]
        :rtype: int
        """
        if not envelopes:
            return 0
        length = len(envelopes)
        d = [1] * length
        envelopes.sort(key = lambda x:(x[0], x[1]))
        result = 1
        for i in range(1, len(envelopes)):
            for j in range(0,i):
                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:
                    d[i] = max(d[i], d[j] + 1)
            result = max(result, d[i])
        return result
```



### **剪绳子 整数拆分**

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        if n<1:
            return 0
        if n==2:
            return 1
        if n==3:
            return 2
        d = [0] * (n+1)
        d[1] = 1
        d[2]=2
        d[3]=3
         
        for i in range(4,len(d)):
            for j in range(1,i//2+1):
                d[i] = max(d[i], d[j] * d[i - j])
        return d[-1]
```







## **设计数据结构**

### **最小栈**

```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.minval = []
        self.stack = []


    def push(self, x: int) -> None:
        if not self.minval:
            self.stack.append(x)
            self.minval.append(x)
        else:
            currentmin=self.minval[-1]
            if currentmin<x:
                self.minval.append(currentmin)
                self.stack.append(x)
            else:
                self.minval.append(x)
                self.stack.append(x)


    def pop(self) -> None:
        if self.minval and self.stack:
            self.minval.pop()
            self.stack.pop()
        else:
            return 

    def top(self) -> int:
        if self.stack:
            return self.stack[-1]
        else:
            return 


    def getMin(self) -> int:
        if self.minval:
            return self.minval[-1]
        else:
            return 


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```



### **LRU缓存机制**

  LRU (最近最少使用) 缓存机制

```python
class DLinkedNode(object):
    def __init__(self, key = 0, value = 0):
        self.key = key 
        self.value = value
        self.prev = None
        self.next = None

class LRUCache(object):

    def __init__(self, capacity):
        """
        :type capacity: int
        用双链表做，重要的有1.从双向链表中删除指定节点的`delete`方法 2.将一个节点插入到双向链表开头的`insert`方法
        每次操作的时候都把操作的元素放到双向链表的开头，如果满了就把最后的节点删除
        """
        self.dic = {}
        self.head = DLinkedNode()
        self.tail = DLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.capacity = capacity

    def insert(self, node):
        node.next, node.prev = self.head.next, self.head
        temp = self.head.next
        self.head.next = node 
        temp.prev = node 

    def delete(self, node):
        node.prev.next, node.next.prev = node.next, node.prev

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key not in self.dic:
            return -1
        node = self.dic[key]
        self.delete(node)
        self.insert(node)
        return node.value 

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: None
        """
        if key in self.dic:
            node = self.dic[key]
            node.value = value
            self.delete(node)
            self.insert(node)
            return
        if len(self.dic) == self.capacity:
            node = self.tail.prev
            self.delete(node)
            del self.dic[node.key]
        node = DLinkedNode(key, value)
        self.dic[key] = node 
        self.insert(node)
```



### **LFU缓存**

最不经常使用

```python
'''
用 带freq值的节点Node，双端链表DLinkedList，哈希表1(key:node)，哈希表2(freq:DLinkedList)，维护min_freq 实现 LFU。
如果超出容量，移除min_freq对应双端链表的尾节点。如果访问，对应node freq+1，并更新其在哈希表2中的位置。

class Node 是每个(key:value)的基本单元，同时具有freq与前后指针。
class DLinkedList 实现 addToHead, removeNode, removeTail 操作，类似LRU管理node节点，使得最经常访问的node在头部，不经常在尾部。
哈希表1(key:node) 实现cache通过key访问node的机制。
哈希表2(freq:DLinkedList)与min_freq 实现基于频率管理node，每个node被放置于哈希表2相应freq中(每个freq下node基于DLinkedList管理)
get操作：如果key在cache中，取出node，freq+1后放入哈希表2 key为freq+1的DLinkedList头部，同时维护min_freq
put操作：如果key已存在，更新node.val，freq+1后放入哈希表2 key为freq+1的DLinkedList头部，同时维护min_freq
如果key不存在，新建node，放入哈希表2 key为1的DLinkedList头部，更新min_freq为1。
如果超过容量，移除哈希表2 min_freq对应DLinkedList中的尾节点，并移除哈希表1中key对应的节点。
'''
class Node:
    def __init__(self, key=-1, val=-1):
        self.key = key
        self.val = val
        self.freq = 1
        self.prev = None
        self.next = None

class DLinkedList:
    def __init__(self):
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0

    def addToHead(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next = node
        node.next.prev = node
        self.size += 1

    def removeNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev
        self.size -= 1

    def removeTail(self):
        node = self.tail.prev
        self.removeNode(node)
        return node

from collections import defaultdict
class LFUCache:
    def __init__(self, capacity: int):
        self.cache = {}
        self.freq = defaultdict(DLinkedList)
        self.size = 0
        self.capacity = capacity
        self.min_freq = 0

    def get(self, key: int) -> int:
        if key in self.cache:
            node = self.cache[key]
            self.freq[node.freq].removeNode(node)
            if self.min_freq == node.freq and self.freq[node.freq].size == 0:
                self.min_freq += 1
            node.freq += 1
            self.freq[node.freq].addToHead(node)  
            return node.val
        return -1

    def put(self, key: int, value: int) -> None:
        if self.capacity == 0:
            return
        if key in self.cache:
            node = self.cache[key]
            node.val = value
            self.freq[node.freq].removeNode(node)
            if self.min_freq == node.freq and self.freq[node.freq].size == 0:
                self.min_freq += 1
            node.freq += 1
            self.freq[node.freq].addToHead(node)
        else:
            self.size += 1
            if self.size > self.capacity:
                node = self.freq[self.min_freq].removeTail()
                self.cache.pop(node.key)
                self.size -= 1
            node = Node(key, value)
            self.cache[key] = node
            self.freq[1].addToHead(node)
            self.min_freq = 1
```







###  **用两个栈实现队列**

```python
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []
        
    def push(self, node):
        # write code here
        self.stack1.append(node)
        
    def pop(self):
        # return xx
        if self.stack2:
            return self.stack2.pop()
        if not self.stack2 and not self.stack1:
            return -1
        while self.stack1:
            self.stack2.append(self.stack1.pop())
        return self.stack2.pop()
```











## **SQL**

### **查询第N高的薪水**

```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  set N := N - 1;
  RETURN (
      # Write your MySQL query statement below.
      select 
      ifnull(
          (select distinct salary from  Employee order by salary desc limit 1 offset N),
         null
      ) as getNthHighestSalary
  );
END
```



### **分数排名**

编写一个 SQL 查询来实现分数排名。

如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。

```sql
select a.Score as Score,
(select count(distinct b.Score) from Scores b where b.Score >= a.Score) as 'rank'
from Scores a 
order by a.Score Desc
```



### **查找所有至少连续出现三次的数字**

```sql
select 
    distinct l1.num as ConsecutiveNums 
from
    Logs l1,
    Logs l2,
    Logs l3 
where
    l1.id = l2.id - 1
    and l2.id = l3.id - 1
    and l1.num = l2.num
    and l2.num = l3.num
```



### **查找收入超过经理收入的员工**

```sql
select 
    a.name as 'Employee'
from 
    employee as a,
    employee as b 
where 
    a.managerId = b.Id 
    and a.salary > b.salary
```



### **查找 Person 表中所有重复的电子邮箱**

```sql
select email from Person group by email having count(email) > 1
```



### **找出所有从不订购任何东西的客户**

某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。

```sql
select Name as Customers
from 
Customers
where 
id not in
(select distinct CustomerId from Orders)
```



### **找出每个部门工资最高的员工**

```sql
SELECT
    b.Name AS Department,
    a.Name AS Employee,
    c.Max_Salary AS Salary
FROM 
    Employee AS a,
    Department AS b,
    (
        SELECT DISTINCT DepartmentId, MAX(Salary) AS Max_Salary
        FROM Employee
        GROUP BY DepartmentId
    ) AS c
WHERE a.DepartmentId = c.DepartmentId
    AND a.DepartmentId = b.Id
    AND a.Salary = c.Max_Salary
```





### **部门工资前三高的所有员工**

```sql
SELECT
    d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary
FROM
    Employee e1
        JOIN
    Department d ON e1.DepartmentId = d.Id
WHERE
    3 > (SELECT
            COUNT(DISTINCT e2.Salary)
        FROM
            Employee e2
        WHERE
            e2.Salary > e1.Salary
                AND e1.DepartmentId = e2.DepartmentId
        )

```



### **删除重复的电子邮箱**

删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。

```sql
delete p1 from Person p1,
        Person p2
where 
p1.email = p2.email and p1.id > p2.id
```



### **查找与之前（昨天的）日期相比温度更高的所有日期的 Id**

```sql
select 
w1.id as 'Id'
from 
weather w1
join 
weather w2
on 
datediff(w1.RecordDate, w2.RecordDate) = 1
and
w1.Temperature > w2.Temperature
```



### **查找所有超过或等于5名学生的课**

有一个courses 表 ，有: student (学生) 和 class (课程)。请列出所有超过或等于5名学生的课。

```sql
select class from courses group by class 
having count(distinct student) >= 5
```



### **更换salary表中的性别**

```sql
UPDATE salary
SET
    sex = CASE sex
        WHEN 'm' THEN 'f'
        ELSE 'm'
    END;
```



### **找出表中有两条记录的人的名字**

```sql
select name from Persons group by name having count(id) = 2
```

